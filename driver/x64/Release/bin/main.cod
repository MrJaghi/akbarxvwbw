; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33145.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	driver_object
PUBLIC	dirbase
PUBLIC	cleanup_thread_handle
PUBLIC	should_stop_cleanup
PUBLIC	monitored_cs2_pid
PUBLIC	monitored_cheat_pid
PUBLIC	g_DeviceName
PUBLIC	g_DosDevices
PUBLIC	pRtlGetVersion
PUBLIC	pMmCopyMemory
PUBLIC	ExPoolZeroingNativelySupported
_BSS	SEGMENT
driver_object DQ 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	dev:BYTE:010H
COMM	dos:BYTE:010H
_DATA	ENDS
_BSS	SEGMENT
dirbase	DQ	01H DUP (?)
cleanup_thread_handle DQ 01H DUP (?)
should_stop_cleanup DB 01H DUP (?)
	ALIGN	4

monitored_cs2_pid DD 01H DUP (?)
monitored_cheat_pid DD 01H DUP (?)
	ALIGN	8

pRtlGetVersion DQ 01H DUP (?)
pMmCopyMemory DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ExPoolZeroingNativelySupported
_BSS	SEGMENT
ExPoolZeroingNativelySupported DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
g_DeviceName DB	0c3H
	DB	0a4H
	DB	0ceH
	DB	0cbH
	DB	0c9H
	DB	0c7H
	DB	0ceH
	DB	0a4H
g_DosDevices DB	0c3H
	DB	0a4H
	DB	0d1H
	DB	0ceH
	DB	0c8H
	DB	0d1H
	DB	0ceH
	DB	0c7H
	DB	0c9H
	DB	0c7H
	DB	0ceH
	DB	0a4H
_DATA	ENDS
PUBLIC	XorDecrypt
PUBLIC	IsDebuggerPresent
PUBLIC	RandomDelay
PUBLIC	GetKernelFunction
PUBLIC	GetUserDirectoryTableBaseOffset
PUBLIC	ReadPhysicalAddress
PUBLIC	WritePhysicalAddress
PUBLIC	TranslateLinearAddress
PUBLIC	IsProcessAlive
PUBLIC	CleanupThreadRoutine
PUBLIC	get_base_address
PUBLIC	unsupported_dispatch
PUBLIC	dispatch
PUBLIC	io_device_control
PUBLIC	unload_driver
PUBLIC	init
PUBLIC	DriverEntry
PUBLIC	??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1FO@IKGKJCMC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$HL?$AA7?$AA7?$AA7?$AA7?$AA7?$AA7@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1GG@LCNBPKCP@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$HL?$AA7?$AA7@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0O@JGECDCHJ@RtlGetVersion@FNODOBFM@	;  ?? ::FNODOBFM::`string'
EXTRN	__imp_RtlInitAnsiString:PROC
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_MmGetSystemRoutineAddress:PROC
EXTRN	__imp_KeDelayExecutionThread:PROC
EXTRN	__imp_MmMapIoSpace:PROC
EXTRN	__imp_MmUnmapIoSpace:PROC
EXTRN	__imp_PsCreateSystemThread:PROC
EXTRN	__imp_PsTerminateSystemThread:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_IoCreateDevice:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteDevice:PROC
EXTRN	__imp_IoDeleteSymbolicLink:PROC
EXTRN	__imp_ObfDereferenceObject:PROC
EXTRN	__imp_PsLookupProcessByProcessId:PROC
EXTRN	__imp_IoCreateDriver:PROC
EXTRN	__imp_PsGetProcessSectionBaseAddress:PROC
EXTRN	__C_specific_handler:PROC
EXTRN	memcpy:PROC
EXTRN	KdDebuggerNotPresent:QWORD
EXTRN	KdDebuggerEnabled:QWORD
EXTRN	__imp_PsInitialSystemProcess:QWORD
EXTRN	__guard_dispatch_icall_fptr:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$RandomDelay DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$RandomDelay
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetKernelFunction DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$GetKernelFunction
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadPhysicalAddress DD imagerel $LN19
	DD	imagerel $LN19+234
	DD	imagerel $unwind$ReadPhysicalAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WritePhysicalAddress DD imagerel $LN15
	DD	imagerel $LN15+238
	DD	imagerel $unwind$WritePhysicalAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TranslateLinearAddress DD imagerel $LN88
	DD	imagerel $LN88+780
	DD	imagerel $unwind$TranslateLinearAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsProcessAlive DD imagerel $LN7
	DD	imagerel $LN7+64
	DD	imagerel $unwind$IsProcessAlive
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CleanupThreadRoutine DD imagerel $LN34
	DD	imagerel $LN34+17
	DD	imagerel $unwind$CleanupThreadRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CleanupThreadRoutine DD imagerel $LN34+17
	DD	imagerel $LN34+262
	DD	imagerel $chain$1$CleanupThreadRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$CleanupThreadRoutine DD imagerel $LN34+262
	DD	imagerel $LN34+275
	DD	imagerel $chain$2$CleanupThreadRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_base_address DD imagerel $LN14
	DD	imagerel $LN14+123
	DD	imagerel $unwind$get_base_address
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unsupported_dispatch DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$unsupported_dispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dispatch DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$dispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$io_device_control DD imagerel $LN69
	DD	imagerel $LN69+1132
	DD	imagerel $unwind$io_device_control
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unload_driver DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$unload_driver
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$init DD	imagerel $LN58
	DD	imagerel $LN58+256
	DD	imagerel $unwind$init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$init DD imagerel $LN58+256
	DD	imagerel $LN58+821
	DD	imagerel $chain$1$init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$init DD imagerel $LN58+821
	DD	imagerel $LN58+838
	DD	imagerel $chain$2$init
pdata	ENDS
;	COMDAT ??_C@_0O@JGECDCHJ@RtlGetVersion@FNODOBFM@
text$s	SEGMENT
??_C@_0O@JGECDCHJ@RtlGetVersion@FNODOBFM@ DB 'RtlGetVersion', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1GG@LCNBPKCP@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$HL?$AA7?$AA7@FNODOBFM@
text$s	SEGMENT
??_C@_1GG@LCNBPKCP@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$HL?$AA7?$AA7@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, '{', 00H, '7'
	DB	00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H
	DB	'7', 00H, '-', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '-'
	DB	00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '-', 00H, '7', 00H
	DB	'7', 00H, '7', 00H, '7', 00H, '-', 00H, '7', 00H, '7', 00H, '7'
	DB	00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H
	DB	'7', 00H, '7', 00H, '7', 00H, '}', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1FO@IKGKJCMC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$HL?$AA7?$AA7?$AA7?$AA7?$AA7?$AA7@FNODOBFM@
text$s	SEGMENT
??_C@_1FO@IKGKJCMC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$HL?$AA7?$AA7?$AA7?$AA7?$AA7?$AA7@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, '{', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '7'
	DB	00H, '7', 00H, '7', 00H, '7', 00H, '-', 00H, '7', 00H, '7', 00H
	DB	'7', 00H, '7', 00H, '-', 00H, '7', 00H, '7', 00H, '7', 00H, '7'
	DB	00H, '-', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '-', 00H
	DB	'7', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '7'
	DB	00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '7', 00H, '}', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@
text$s	SEGMENT
??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@ DB 'MmCopyMemory', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT gfids$y
gfids$y	SEGMENT
__guard_fids_DriverEntry DDSymXIndex:  FLAT:init
gfids$y	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$init DD 020022H
	DD	06001602H
	DD	imagerel $LN58
	DD	imagerel $LN58+256
	DD	imagerel $unwind$init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$init DD 020822H
	DD	0157408H
	DD	imagerel $LN58
	DD	imagerel $LN58+256
	DD	imagerel $unwind$init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init DD	072b02H
	DD	06df0602H
	DD	014642bH
	DD	0120109H
	DD	03002H
xdata	ENDS
;	COMDAT gfids$y
gfids$y	SEGMENT
__guard_fids_init DDSymXIndex:  FLAT:CleanupThreadRoutine
	DDSymXIndex: 	FLAT:unload_driver
	DDSymXIndex: 	FLAT:io_device_control
	DDSymXIndex: 	FLAT:dispatch
	DDSymXIndex: 	FLAT:dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
	DDSymXIndex: 	FLAT:unsupported_dispatch
gfids$y	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unload_driver DD 030402H
	DD	06001601H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$io_device_control DD 0a160aH
	DD	06001609H
	DD	0143416H
	DD	0f012d216H
	DD	0d00ee010H
	DD	0600b700cH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN69+94
	DD	imagerel $LN69+1066
	DD	01H
	DD	imagerel $LN69+1066
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dispatch DD 030402H
	DD	06001601H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unsupported_dispatch DD 030402H
	DD	06001601H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_base_address DD 060a02H
	DD	06121602H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$CleanupThreadRoutine DD 020022H
	DD	06001607H
	DD	imagerel $LN34
	DD	imagerel $LN34+17
	DD	imagerel $unwind$CleanupThreadRoutine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CleanupThreadRoutine DD 040a22H
	DD	04740aH
	DD	063405H
	DD	imagerel $LN34
	DD	imagerel $LN34+17
	DD	imagerel $unwind$CleanupThreadRoutine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CleanupThreadRoutine DD 010402H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsProcessAlive DD 030402H
	DD	06081601H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TranslateLinearAddress DD 0c1702H
	DD	0600160cH
	DD	0133417H
	DD	0f0109217H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WritePhysicalAddress DD 0a120aH
	DD	06181605H
	DD	06740642H
	DD	093412H
	DD	0e00e3212H
	DD	0600b700cH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN15+127
	DD	imagerel $LN15+144
	DD	01H
	DD	imagerel $LN15+177
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadPhysicalAddress DD 0a1402H
	DD	06001602H
	DD	0d6414H
	DD	0c5414H
	DD	0b3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetKernelFunction DD 030402H
	DD	06001601H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RandomDelay DD 030402H
	DD	06001601H
	DD	04204H
xdata	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT DriverEntry
_TEXT	SEGMENT
driver$ = 8
path$ = 16
DriverEntry PROC					; COMDAT

; 667  : 	UNREFERENCED_PARAMETER(path);
; 668  : 	UNREFERENCED_PARAMETER(driver);
; 669  : 
; 670  : 	return IoCreateDriver(NULL, &init);

  00000	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:init
  00007	33 c9		 xor	 ecx, ecx
  00009	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_IoCreateDriver
DriverEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT init
_TEXT	SEGMENT
name$2 = 64
name$3 = 64
clientId$ = 80
objAttr$ = 96
driver$ = 160
path$ = 168
interval$4 = 176
interval$5 = 176
init	PROC						; COMDAT

; 595  : {

$LN58:
  00000	40 53		 push	 rbx
  00002	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00009	48 8b d9	 mov	 rbx, rcx

; 596  : 	UNREFERENCED_PARAMETER(path);
; 597  : 
; 598  : 	// Multi-layer anti-debug
; 599  : 	if (IsDebuggerPresent())

  0000c	e8 00 00 00 00	 call	 IsDebuggerPresent
  00011	84 c0		 test	 al, al
  00013	74 0e		 je	 SHORT $LN5@init

; 600  : 		return STATUS_ACCESS_DENIED;

  00015	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H

; 662  : }

  0001a	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
$LN5@init:
  00023	48 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rsi

; 68   : 	ULONG random = (ULONG)(__rdtsc() % 150);

  0002b	0f 31		 rdtsc
  0002d	48 c1 e2 20	 shl	 rdx, 32			; 00000020H
  00031	48 be 07 3a 6d
	a0 d3 06 3a 6d	 mov	 rsi, 7870610804782742023 ; 6d3a06d3a06d3a07H
  0003b	48 0b c2	 or	 rax, rdx
  0003e	4c 8b c0	 mov	 r8, rax
  00041	48 8b c6	 mov	 rax, rsi
  00044	49 f7 e0	 mul	 r8
  00047	48 c1 ea 06	 shr	 rdx, 6
  0004b	48 69 ca 96 00
	00 00		 imul	 rcx, rdx, 150		; 00000096H

; 69   : 	interval.QuadPart = -(10000LL * random);
; 70   : 	KeDelayExecutionThread(KernelMode, FALSE, &interval);

  00052	33 d2		 xor	 edx, edx
  00054	4c 2b c1	 sub	 r8, rcx
  00057	41 8b c0	 mov	 eax, r8d
  0005a	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR interval$5[rsp]
  00062	48 69 c8 f0 d8
	ff ff		 imul	 rcx, rax, -10000	; ffffffffffffd8f0H
  00069	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR interval$5[rsp], rcx
  00071	33 c9		 xor	 ecx, ecx
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeDelayExecutionThread

; 601  : 
; 602  : 	RandomDelay();
; 603  : 
; 604  : 	NTSTATUS status = STATUS_SUCCESS;
; 605  : 
; 606  : 	RtlInitUnicodeString(&dev, drv_device);

  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1FO@IKGKJCMC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$HL?$AA7?$AA7?$AA7?$AA7?$AA7?$AA7@FNODOBFM@
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dev
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 607  : 	RtlInitUnicodeString(&dos, drv_dos_device);

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1GG@LCNBPKCP@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AA?$HL?$AA7?$AA7@FNODOBFM@
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 608  : 
; 609  : 	// Clean up any existing device
; 610  : 	IoDeleteSymbolicLink(&dos);

  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 611  : 	if (driver_object)

  000ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR driver_object
  000b5	48 85 c9	 test	 rcx, rcx
  000b8	74 06		 je	 SHORT $LN6@init

; 612  : 		IoDeleteDevice(driver_object);

  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice
$LN6@init:

; 613  : 
; 614  : 	status = IoCreateDevice(driver, 0, &dev, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &driver_object);

  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:driver_object
  000c7	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  000cd	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:dev
  000d9	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  000de	33 d2		 xor	 edx, edx
  000e0	48 8b cb	 mov	 rcx, rbx
  000e3	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 615  : 	if (!NT_SUCCESS(status))

  000f1	85 c0		 test	 eax, eax
  000f3	0f 88 3c 02 00
	00		 js	 $LN55@init

; 616  : 		return status;
; 617  : 
; 618  : 	status = IoCreateSymbolicLink(&dos, &dev);

  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dev
  00100	48 89 bc 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rdi
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink
  00115	8b f8		 mov	 edi, eax

; 619  : 	if (!NT_SUCCESS(status))

  00117	85 c0		 test	 eax, eax
  00119	79 25		 jns	 SHORT $LL8@init

; 620  : 	{
; 621  : 		IoDeleteDevice(driver_object);

  0011b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR driver_object
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 622  : 		driver_object = NULL;

  00128	33 db		 xor	 ebx, ebx

; 623  : 		return status;

  0012a	8b c7		 mov	 eax, edi
  0012c	48 89 1d 00 00
	00 00		 mov	 QWORD PTR driver_object, rbx
  00133	e9 f5 01 00 00	 jmp	 $LN56@init
  00138	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL8@init:

; 624  : 	}
; 625  : 
; 626  : 	// Setup dispatch routines
; 627  : 	for (int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
; 628  : 		driver->MajorFunction[i] = &unsupported_dispatch;

  00140	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:unsupported_dispatch
  00147	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@JGECDCHJ@RtlGetVersion@FNODOBFM@

; 624  : 	}
; 625  : 
; 626  : 	// Setup dispatch routines
; 627  : 	for (int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
; 628  : 		driver->MajorFunction[i] = &unsupported_dispatch;

  00152	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  00159	48 8d 4c 24 40	 lea	 rcx, QWORD PTR name$3[rsp]

; 624  : 	}
; 625  : 
; 626  : 	// Setup dispatch routines
; 627  : 	for (int i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
; 628  : 		driver->MajorFunction[i] = &unsupported_dispatch;

  0015e	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax
  00165	48 89 83 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rax
  0016c	48 89 83 a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rax
  00173	48 89 83 a8 00
	00 00		 mov	 QWORD PTR [rbx+168], rax
  0017a	48 89 83 b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rax
  00181	48 89 83 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rax
  00188	48 89 83 c0 00
	00 00		 mov	 QWORD PTR [rbx+192], rax
  0018f	48 89 83 c8 00
	00 00		 mov	 QWORD PTR [rbx+200], rax
  00196	48 89 83 d0 00
	00 00		 mov	 QWORD PTR [rbx+208], rax
  0019d	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax
  001a4	48 89 83 e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rax
  001ab	48 89 83 f0 00
	00 00		 mov	 QWORD PTR [rbx+240], rax
  001b2	48 89 83 f8 00
	00 00		 mov	 QWORD PTR [rbx+248], rax
  001b9	48 89 83 00 01
	00 00		 mov	 QWORD PTR [rbx+256], rax
  001c0	48 89 83 08 01
	00 00		 mov	 QWORD PTR [rbx+264], rax
  001c7	48 89 83 10 01
	00 00		 mov	 QWORD PTR [rbx+272], rax
  001ce	48 89 83 18 01
	00 00		 mov	 QWORD PTR [rbx+280], rax
  001d5	48 89 83 20 01
	00 00		 mov	 QWORD PTR [rbx+288], rax
  001dc	48 89 83 28 01
	00 00		 mov	 QWORD PTR [rbx+296], rax
  001e3	48 89 83 30 01
	00 00		 mov	 QWORD PTR [rbx+304], rax
  001ea	48 89 83 38 01
	00 00		 mov	 QWORD PTR [rbx+312], rax
  001f1	48 89 83 40 01
	00 00		 mov	 QWORD PTR [rbx+320], rax
  001f8	48 89 83 48 01
	00 00		 mov	 QWORD PTR [rbx+328], rax

; 629  : 
; 630  : 	driver->MajorFunction[IRP_MJ_CREATE] = &dispatch;

  001ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dispatch
  00206	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 631  : 	driver->MajorFunction[IRP_MJ_CLOSE] = &dispatch;

  0020a	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 632  : 	driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &io_device_control;

  00211	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:io_device_control
  00218	48 89 83 e0 00
	00 00		 mov	 QWORD PTR [rbx+224], rax

; 633  : 	driver->DriverUnload = &unload_driver;

  0021f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:unload_driver
  00226	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 634  : 
; 635  : 	driver_object->Flags |= DO_BUFFERED_IO;

  0022a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR driver_object
  00231	83 48 30 04	 or	 DWORD PTR [rax+48], 4

; 636  : 	driver_object->Flags &= ~DO_DEVICE_INITIALIZING;

  00235	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR driver_object
  0023c	81 60 30 7f ff
	ff ff		 and	 DWORD PTR [rax+48], -129 ; ffffff7fH

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 85   : 	
; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  00249	48 8d 4c 24 40	 lea	 rcx, QWORD PTR name$3[rsp]
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  00254	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@

; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  0025b	48 89 05 00 00
	00 00		 mov	 QWORD PTR pRtlGetVersion, rax

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  00262	48 8d 4c 24 40	 lea	 rcx, QWORD PTR name$2[rsp]
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 85   : 	
; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  0026d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR name$2[rsp]
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress

; 637  : 
; 638  : 	// Initialize function pointers dynamically
; 639  : 	pRtlGetVersion = (fnRtlGetVersion)GetKernelFunction((PUCHAR)"RtlGetVersion");
; 640  : 	pMmCopyMemory = (fnMmCopyMemory)GetKernelFunction((PUCHAR)"MmCopyMemory");
; 641  : 
; 642  : 	// Create cleanup monitoring thread
; 643  : 	CLIENT_ID clientId;
; 644  : 	OBJECT_ATTRIBUTES objAttr;
; 645  : 	InitializeObjectAttributes(&objAttr, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

  00278	33 db		 xor	 ebx, ebx
  0027a	c7 44 24 60 30
	00 00 00	 mov	 DWORD PTR objAttr$[rsp], 48 ; 00000030H

; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  00282	48 89 05 00 00
	00 00		 mov	 QWORD PTR pMmCopyMemory, rax

; 646  : 
; 647  : 	status = PsCreateSystemThread(

  00289	4c 8d 44 24 60	 lea	 r8, QWORD PTR objAttr$[rsp]
  0028e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CleanupThreadRoutine
  00295	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0029a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cleanup_thread_handle
  002a6	48 8d 44 24 50	 lea	 rax, QWORD PTR clientId$[rsp]
  002ab	48 89 5c 24 68	 mov	 QWORD PTR objAttr$[rsp+8], rbx
  002b0	0f 57 c0	 xorps	 xmm0, xmm0
  002b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b8	45 33 c9	 xor	 r9d, r9d
  002bb	c7 44 24 78 00
	02 00 00	 mov	 DWORD PTR objAttr$[rsp+24], 512 ; 00000200H
  002c3	ba ff ff 1f 00	 mov	 edx, 2097151		; 001fffffH
  002c8	48 89 5c 24 70	 mov	 QWORD PTR objAttr$[rsp+16], rbx
  002cd	f3 0f 7f 84 24
	80 00 00 00	 movdqu	 XMMWORD PTR objAttr$[rsp+32], xmm0
  002d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsCreateSystemThread

; 648  : 		&cleanup_thread_handle,
; 649  : 		THREAD_ALL_ACCESS,
; 650  : 		&objAttr,
; 651  : 		NULL,
; 652  : 		&clientId,
; 653  : 		CleanupThreadRoutine,
; 654  : 		NULL
; 655  : 	);
; 656  : 
; 657  : 	if (!NT_SUCCESS(status))

  002dc	85 c0		 test	 eax, eax
  002de	79 07		 jns	 SHORT $LN9@init

; 658  : 		cleanup_thread_handle = NULL;

  002e0	48 89 1d 00 00
	00 00		 mov	 QWORD PTR cleanup_thread_handle, rbx
$LN9@init:

; 68   : 	ULONG random = (ULONG)(__rdtsc() % 150);

  002e7	0f 31		 rdtsc
  002e9	48 c1 e2 20	 shl	 rdx, 32			; 00000020H
  002ed	48 0b c2	 or	 rax, rdx
  002f0	4c 8b c0	 mov	 r8, rax
  002f3	48 8b c6	 mov	 rax, rsi
  002f6	49 f7 e0	 mul	 r8
  002f9	48 c1 ea 06	 shr	 rdx, 6
  002fd	48 69 ca 96 00
	00 00		 imul	 rcx, rdx, 150		; 00000096H

; 69   : 	interval.QuadPart = -(10000LL * random);
; 70   : 	KeDelayExecutionThread(KernelMode, FALSE, &interval);

  00304	33 d2		 xor	 edx, edx
  00306	4c 2b c1	 sub	 r8, rcx
  00309	41 8b c0	 mov	 eax, r8d
  0030c	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR interval$4[rsp]
  00314	48 69 c8 f0 d8
	ff ff		 imul	 rcx, rax, -10000	; ffffffffffffd8f0H
  0031b	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR interval$4[rsp], rcx
  00323	33 c9		 xor	 ecx, ecx
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeDelayExecutionThread

; 659  : 
; 660  : 	RandomDelay();
; 661  : 	return STATUS_SUCCESS;

  0032b	33 c0		 xor	 eax, eax
$LN56@init:
  0032d	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+168]
$LN55@init:
  00335	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]

; 662  : }

  0033d	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00344	5b		 pop	 rbx
  00345	c3		 ret	 0
init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT unload_driver
_TEXT	SEGMENT
driver$ = 48
unload_driver PROC					; COMDAT

; 582  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 583  : 	UNREFERENCED_PARAMETER(driver);
; 584  : 
; 585  : 	if (driver_object)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR driver_object, 0
  0000c	74 25		 je	 SHORT $LN2@unload_dri

; 586  : 	{
; 587  : 		IoDeleteSymbolicLink(&dos);

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 588  : 		IoDeleteDevice(driver_object);

  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR driver_object
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 589  : 		driver_object = NULL;

  00028	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR driver_object, 0
$LN2@unload_dri:

; 590  : 	}
; 591  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
unload_driver ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT io_device_control
_TEXT	SEGMENT
status$ = 32
info_size$ = 40
BytesWritten$1 = 48
target_proc$2 = 56
BytesRead$3 = 64
TotalSize$4 = 72
CurOffset$5 = 80
TotalSize$6 = 88
CurOffset$7 = 96
device$ = 160
irp$ = 168
target_proc$8 = 176
target_proc$9 = 184
io_device_control PROC					; COMDAT

; 331  : {

$LN69:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00016	4c 8b ea	 mov	 r13, rdx

; 332  : 	UNREFERENCED_PARAMETER(device);
; 333  : 
; 334  : 	// Anti-debug check on every IOCTL
; 335  : 	if (IsDebuggerPresent())

  00019	e8 00 00 00 00	 call	 IsDebuggerPresent
  0001e	45 33 ff	 xor	 r15d, r15d
  00021	84 c0		 test	 al, al
  00023	74 21		 je	 SHORT $LN8@io_device_

; 336  : 	{
; 337  : 		irp->IoStatus.Status = STATUS_ACCESS_DENIED;

  00025	41 c7 45 30 22
	00 00 c0	 mov	 DWORD PTR [r13+48], -1073741790 ; ffffffffc0000022H

; 338  : 		irp->IoStatus.Information = 0;

  0002d	4d 89 7d 38	 mov	 QWORD PTR [r13+56], r15

; 339  : 		IoCompleteRequest(irp, IO_NO_INCREMENT);

  00031	33 d2		 xor	 edx, edx
  00033	49 8b cd	 mov	 rcx, r13
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 340  : 		return STATUS_ACCESS_DENIED;

  0003c	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00041	e9 11 04 00 00	 jmp	 $LN1@io_device_
$LN8@io_device_:

; 341  : 	}
; 342  : 
; 343  : 	NTSTATUS status = STATUS_SUCCESS;
; 344  : 	ULONG_PTR info_size = 0;

  00046	49 8b f7	 mov	 rsi, r15

; 345  : 
; 346  : 	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);

  00049	49 8b 85 b8 00
	00 00		 mov	 rax, QWORD PTR [r13+184]

; 347  : 	ULONG ctl_code = stack->Parameters.DeviceIoControl.IoControlCode;

  00050	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]

; 348  : 	ULONG input_len = stack->Parameters.DeviceIoControl.InputBufferLength;

  00053	8b 50 10	 mov	 edx, DWORD PTR [rax+16]

; 349  : 	ULONG output_len = stack->Parameters.DeviceIoControl.OutputBufferLength;

  00056	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]

; 350  : 	PVOID buffer = irp->AssociatedIrp.SystemBuffer;

  0005a	49 8b 7d 18	 mov	 rdi, QWORD PTR [r13+24]

; 351  : 
; 352  : 	__try
; 353  : 	{
; 354  : 		switch (ctl_code)

  0005e	81 f9 fc a9 22
	00		 cmp	 ecx, 2271740		; 0022a9fcH
  00064	0f 84 90 02 00
	00		 je	 $LN19@io_device_
  0006a	81 f9 38 ee 22
	00		 cmp	 ecx, 2289208		; 0022ee38H
  00070	0f 84 58 01 00
	00		 je	 $LN29@io_device_
  00076	81 f9 74 32 23
	00		 cmp	 ecx, 2306676		; 00233274H
  0007c	0f 84 08 01 00
	00		 je	 $LN39@io_device_
  00082	81 f9 b0 76 23
	00		 cmp	 ecx, 2324144		; 002376b0H
  00088	74 5a		 je	 SHORT $LN10@io_device_
  0008a	81 f9 f4 ba 23
	00		 cmp	 ecx, 2341620		; 0023baf4H
  00090	74 13		 je	 SHORT $LN44@io_device_

; 560  : 		}
; 561  : 
; 562  : 		default:
; 563  : 			status = STATUS_INVALID_DEVICE_REQUEST;

  00092	bb 10 00 00 c0	 mov	 ebx, -1073741808	; ffffffffc0000010H
  00097	89 5c 24 20	 mov	 DWORD PTR status$[rsp], ebx

; 564  : 			info_size = 0;

  0009b	4c 89 7c 24 28	 mov	 QWORD PTR info_size$[rsp], r15
  000a0	e9 83 03 00 00	 jmp	 $LN2@io_device_
$LN44@io_device_:

; 546  : 			break;
; 547  : 		}
; 548  : 
; 549  : 		case soardrv_shutdown:
; 550  : 		{
; 551  : 			if (driver_object)

  000a5	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR driver_object, 0
  000ad	74 21		 je	 SHORT $LN45@io_device_

; 552  : 			{
; 553  : 				IoDeleteSymbolicLink(&dos);

  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 554  : 				IoDeleteDevice(driver_object);

  000bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR driver_object
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 555  : 				driver_object = NULL;

  000c9	4c 89 3d 00 00
	00 00		 mov	 QWORD PTR driver_object, r15
$LN45@io_device_:

; 556  : 			}
; 557  : 			status = STATUS_SUCCESS;

  000d0	41 8b df	 mov	 ebx, r15d
  000d3	89 5c 24 20	 mov	 DWORD PTR status$[rsp], ebx

; 558  : 			info_size = 0;

  000d7	49 8b f7	 mov	 rsi, r15
  000da	4c 89 7c 24 28	 mov	 QWORD PTR info_size$[rsp], r15

; 559  : 			break;

  000df	e9 44 03 00 00	 jmp	 $LN2@io_device_
$LN10@io_device_:

; 355  : 		{
; 356  : 		case soardrv_get_cr3:
; 357  : 		{
; 358  : 			if (output_len < sizeof(soardrv_cr3))

  000e4	41 83 f8 18	 cmp	 r8d, 24
  000e8	73 0a		 jae	 SHORT $LN11@io_device_
$LN41@io_device_:

; 565  : 			break;
; 566  : 		}
; 567  : 	}

  000ea	bb 23 00 00 c0	 mov	 ebx, -1073741789	; ffffffffc0000023H
  000ef	e9 30 03 00 00	 jmp	 $LN65@io_device_
$LN11@io_device_:

; 359  : 			{
; 360  : 				status = STATUS_BUFFER_TOO_SMALL;
; 361  : 				break;
; 362  : 			}
; 363  : 
; 364  : 			soardrv_cr3_mod in = (soardrv_cr3_mod)buffer;
; 365  : 			if (!in || !in->pid)

  000f4	48 85 ff	 test	 rdi, rdi
  000f7	0f 84 22 03 00
	00		 je	 $LN22@io_device_
  000fd	8b 07		 mov	 eax, DWORD PTR [rdi]
  000ff	85 c0		 test	 eax, eax
  00101	0f 84 18 03 00
	00		 je	 $LN22@io_device_

; 366  : 			{
; 367  : 				status = STATUS_INVALID_PARAMETER;
; 368  : 				break;
; 369  : 			}
; 370  : 
; 371  : 			// Store PID for monitoring
; 372  : 			if (monitored_cs2_pid == 0)

  00107	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR monitored_cs2_pid, 0
  0010e	75 06		 jne	 SHORT $LN14@io_device_

; 373  : 				monitored_cs2_pid = in->pid;

  00110	89 05 00 00 00
	00		 mov	 DWORD PTR monitored_cs2_pid, eax
$LN14@io_device_:

; 374  : 
; 375  : 			// FIXED: Use the PID from input to get target process CR3
; 376  : 			PEPROCESS target_proc = NULL;

  00116	4c 89 bc 24 b0
	00 00 00	 mov	 QWORD PTR target_proc$8[rsp], r15

; 377  : 			status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)in->pid, &target_proc);

  0011e	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00120	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR target_proc$8[rsp]
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId
  0012e	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 378  : 
; 379  : 			if (!NT_SUCCESS(status) || !target_proc)

  00132	85 c0		 test	 eax, eax
  00134	0f 88 e5 02 00
	00		 js	 $LN22@io_device_
  0013a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR target_proc$8[rsp]
  00142	48 85 c9	 test	 rcx, rcx
  00145	0f 84 d4 02 00
	00		 je	 $LN22@io_device_

; 380  : 			{
; 381  : 				status = STATUS_INVALID_PARAMETER;
; 382  : 				break;
; 383  : 			}
; 384  : 
; 385  : 			ULONG64 process_dirbase = 0;
; 386  : 			uintptr_t offset = GetUserDirectoryTableBaseOffset();
; 387  : 
; 388  : 			if (offset)
; 389  : 			{
; 390  : 				// Read CR3 from EPROCESS using byte pointer arithmetic
; 391  : 				PUCHAR proc_ptr = (PUCHAR)target_proc;
; 392  : 				RtlCopyMemory(&process_dirbase, proc_ptr + offset, sizeof(process_dirbase));

  0014b	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 393  : 				dirbase = process_dirbase;

  0014f	48 89 05 00 00
	00 00		 mov	 QWORD PTR dirbase, rax

; 394  : 				in->cr3 = process_dirbase;

  00156	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 395  : 				in->base = (ULONG64)target_proc;

  0015a	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx

; 396  : 			}
; 397  : 
; 398  : 			ObDereferenceObject(target_proc);

  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 399  : 
; 400  : 			if (!dirbase)

  00164	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dirbase, 0
  0016c	75 0a		 jne	 SHORT $LN18@io_device_

; 401  : 			{
; 402  : 				status = STATUS_NOT_FOUND;

  0016e	bb 25 02 00 c0	 mov	 ebx, -1073741275	; ffffffffc0000225H

; 403  : 				break;

  00173	e9 ac 02 00 00	 jmp	 $LN65@io_device_
$LN18@io_device_:

; 404  : 			}
; 405  : 
; 406  : 			info_size = sizeof(soardrv_cr3);

  00178	be 18 00 00 00	 mov	 esi, 24
  0017d	48 89 74 24 28	 mov	 QWORD PTR info_size$[rsp], rsi

; 407  : 			status = STATUS_SUCCESS;

  00182	41 8b df	 mov	 ebx, r15d

; 408  : 			break;

  00185	e9 9a 02 00 00	 jmp	 $LN65@io_device_
$LN39@io_device_:

; 524  : 
; 525  : 			info_size = sizeof(soardrv_rw);
; 526  : 			break;
; 527  : 		}
; 528  : 
; 529  : 		case soardrv_get_process_base:
; 530  : 		{
; 531  : 			if (input_len < sizeof(soardrv_base) || output_len < sizeof(soardrv_base))

  0018a	83 fa 10	 cmp	 edx, 16
  0018d	0f 82 57 ff ff
	ff		 jb	 $LN41@io_device_
  00193	41 83 f8 10	 cmp	 r8d, 16
  00197	0f 82 4d ff ff
	ff		 jb	 $LN41@io_device_

; 532  : 			{
; 533  : 				status = STATUS_BUFFER_TOO_SMALL;
; 534  : 				break;
; 535  : 			}
; 536  : 
; 537  : 			soardrv_base_mod in = (soardrv_base_mod)buffer;
; 538  : 			if (!in || !in->pid)

  0019d	48 85 ff	 test	 rdi, rdi
  001a0	0f 84 79 02 00
	00		 je	 $LN22@io_device_
  001a6	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  001a8	85 c9		 test	 ecx, ecx
  001aa	0f 84 6f 02 00
	00		 je	 $LN22@io_device_

; 542  : 			}
; 543  : 
; 544  : 			status = get_base_address(in->pid, &in->handle);

  001b0	48 8d 57 08	 lea	 rdx, QWORD PTR [rdi+8]
  001b4	e8 00 00 00 00	 call	 get_base_address
  001b9	8b d8		 mov	 ebx, eax
  001bb	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 545  : 			info_size = sizeof(soardrv_base);

  001bf	be 10 00 00 00	 mov	 esi, 16
  001c4	48 89 74 24 28	 mov	 QWORD PTR info_size$[rsp], rsi

; 539  : 			{
; 540  : 				status = STATUS_INVALID_PARAMETER;
; 541  : 				break;

  001c9	e9 5a 02 00 00	 jmp	 $LN2@io_device_
$LN29@io_device_:

; 465  : 
; 466  : 			info_size = sizeof(soardrv_rw);
; 467  : 			break;
; 468  : 		}
; 469  : 
; 470  : 		case soardrv_write_physical:
; 471  : 		{
; 472  : 			if (input_len < sizeof(soardrv_rw))

  001ce	83 fa 20	 cmp	 edx, 32			; 00000020H
  001d1	73 0a		 jae	 SHORT $LN30@io_device_

; 473  : 			{
; 474  : 				status = STATUS_BUFFER_TOO_SMALL;

  001d3	bb 23 00 00 c0	 mov	 ebx, -1073741789	; ffffffffc0000023H

; 475  : 				break;

  001d8	e9 47 02 00 00	 jmp	 $LN65@io_device_
$LN30@io_device_:

; 476  : 			}
; 477  : 
; 478  : 			soardrv_rw_mod in = (soardrv_rw_mod)buffer;
; 479  : 			if (!in || !in->src || !in->dst || !in->size || in->size > 0x100000)

  001dd	48 85 ff	 test	 rdi, rdi
  001e0	0f 84 39 02 00
	00		 je	 $LN22@io_device_
  001e6	48 83 7f 08 00	 cmp	 QWORD PTR [rdi+8], 0
  001eb	0f 84 2e 02 00
	00		 je	 $LN22@io_device_
  001f1	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  001f6	0f 84 23 02 00
	00		 je	 $LN22@io_device_
  001fc	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00200	48 ff c8	 dec	 rax
  00203	48 3d ff ff 0f
	00		 cmp	 rax, 1048575		; 000fffffH
  00209	0f 87 10 02 00
	00		 ja	 $LN22@io_device_

; 480  : 			{
; 481  : 				status = STATUS_INVALID_PARAMETER;
; 482  : 				break;
; 483  : 			}
; 484  : 
; 485  : 			if (!dirbase)

  0020f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dirbase, 0
  00217	75 0a		 jne	 SHORT $LN33@io_device_

; 486  : 			{
; 487  : 				status = STATUS_DEVICE_NOT_READY;

  00219	bb a3 00 00 c0	 mov	 ebx, -1073741661	; ffffffffc00000a3H

; 488  : 				break;

  0021e	e9 01 02 00 00	 jmp	 $LN65@io_device_
$LN33@io_device_:

; 489  : 			}
; 490  : 
; 491  : 			PEPROCESS target_proc = NULL;

  00223	4c 89 bc 24 b8
	00 00 00	 mov	 QWORD PTR target_proc$9[rsp], r15

; 492  : 			status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)in->pid, &target_proc);

  0022b	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  0022d	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR target_proc$9[rsp]
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId
  0023b	8b d8		 mov	 ebx, eax
  0023d	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 493  : 			if (!NT_SUCCESS(status) || !target_proc)

  00241	85 c0		 test	 eax, eax
  00243	0f 88 d6 01 00
	00		 js	 $LN22@io_device_
  00249	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR target_proc$9[rsp]
  00251	48 85 c9	 test	 rcx, rcx
  00254	0f 84 c5 01 00
	00		 je	 $LN22@io_device_

; 494  : 			{
; 495  : 				status = STATUS_INVALID_PARAMETER;
; 496  : 				break;
; 497  : 			}
; 498  : 
; 499  : 			ObDereferenceObject(target_proc);

  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 500  : 
; 501  : 			SIZE_T CurOffset = 0;

  00260	4d 8b f7	 mov	 r14, r15
  00263	4c 89 7c 24 50	 mov	 QWORD PTR CurOffset$5[rsp], r15

; 502  : 			SIZE_T TotalSize = in->size;

  00268	48 8b 77 18	 mov	 rsi, QWORD PTR [rdi+24]
  0026c	48 89 74 24 48	 mov	 QWORD PTR TotalSize$4[rsp], rsi
$LL6@io_device_:

; 503  : 
; 504  : 			while (TotalSize > 0)

  00271	48 85 f6	 test	 rsi, rsi
  00274	0f 84 99 01 00
	00		 je	 $LN28@io_device_

; 505  : 			{
; 506  : 				INT64 CurPhysAddr = TranslateLinearAddress(dirbase, in->src + CurOffset);

  0027a	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0027e	49 03 d6	 add	 rdx, r14
  00281	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dirbase
  00288	e8 00 00 00 00	 call	 TranslateLinearAddress
  0028d	4c 8b d0	 mov	 r10, rax

; 507  : 				if (!CurPhysAddr)

  00290	48 85 c0	 test	 rax, rax
  00293	0f 84 71 01 00
	00		 je	 $LN67@io_device_

; 508  : 				{
; 509  : 					status = STATUS_UNSUCCESSFUL;
; 510  : 					break;
; 511  : 				}
; 512  : 
; 513  : 				ULONG64 WriteSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);

  00299	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0029e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  002a3	48 2b c8	 sub	 rcx, rax
  002a6	4c 8b c6	 mov	 r8, rsi
  002a9	48 3b ce	 cmp	 rcx, rsi
  002ac	4c 0f 42 c1	 cmovb	 r8, rcx

; 514  : 				SIZE_T BytesWritten = 0;

  002b0	4c 89 7c 24 30	 mov	 QWORD PTR BytesWritten$1[rsp], r15

; 515  : 
; 516  : 				status = WritePhysicalAddress((PVOID)CurPhysAddr, (PVOID)(in->dst + CurOffset), WriteSize, &BytesWritten);

  002b5	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  002b9	49 03 d6	 add	 rdx, r14
  002bc	4c 8d 4c 24 30	 lea	 r9, QWORD PTR BytesWritten$1[rsp]
  002c1	49 8b ca	 mov	 rcx, r10
  002c4	e8 00 00 00 00	 call	 WritePhysicalAddress
  002c9	8b d8		 mov	 ebx, eax
  002cb	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 517  : 
; 518  : 				if (!NT_SUCCESS(status) || BytesWritten == 0)

  002cf	85 c0		 test	 eax, eax
  002d1	0f 88 3c 01 00
	00		 js	 $LN28@io_device_
  002d7	48 8b 44 24 30	 mov	 rax, QWORD PTR BytesWritten$1[rsp]
  002dc	48 85 c0	 test	 rax, rax
  002df	0f 84 2e 01 00
	00		 je	 $LN28@io_device_

; 519  : 					break;
; 520  : 
; 521  : 				TotalSize -= BytesWritten;

  002e5	48 2b f0	 sub	 rsi, rax
  002e8	48 89 74 24 48	 mov	 QWORD PTR TotalSize$4[rsp], rsi

; 522  : 				CurOffset += BytesWritten;

  002ed	4c 03 f0	 add	 r14, rax
  002f0	4c 89 74 24 50	 mov	 QWORD PTR CurOffset$5[rsp], r14

; 523  : 			}

  002f5	e9 77 ff ff ff	 jmp	 $LL6@io_device_
$LN19@io_device_:

; 409  : 		}
; 410  : 
; 411  : 		case soardrv_read_physical:
; 412  : 		{
; 413  : 			if (input_len < sizeof(soardrv_rw))

  002fa	83 fa 20	 cmp	 edx, 32			; 00000020H
  002fd	73 0a		 jae	 SHORT $LN20@io_device_

; 414  : 			{
; 415  : 				status = STATUS_BUFFER_TOO_SMALL;

  002ff	bb 23 00 00 c0	 mov	 ebx, -1073741789	; ffffffffc0000023H

; 416  : 				break;

  00304	e9 1b 01 00 00	 jmp	 $LN65@io_device_
$LN20@io_device_:

; 417  : 			}
; 418  : 
; 419  : 			soardrv_rw_mod in = (soardrv_rw_mod)buffer;
; 420  : 			if (!in || !in->src || !in->dst || !in->size || in->size > 0x100000)

  00309	48 85 ff	 test	 rdi, rdi
  0030c	0f 84 0d 01 00
	00		 je	 $LN22@io_device_
  00312	48 83 7f 08 00	 cmp	 QWORD PTR [rdi+8], 0
  00317	0f 84 02 01 00
	00		 je	 $LN22@io_device_
  0031d	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  00322	0f 84 f7 00 00
	00		 je	 $LN22@io_device_
  00328	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  0032c	48 ff c8	 dec	 rax
  0032f	48 3d ff ff 0f
	00		 cmp	 rax, 1048575		; 000fffffH
  00335	0f 87 e4 00 00
	00		 ja	 $LN22@io_device_

; 421  : 			{
; 422  : 				status = STATUS_INVALID_PARAMETER;
; 423  : 				break;
; 424  : 			}
; 425  : 
; 426  : 			if (!dirbase)

  0033b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dirbase, 0
  00343	75 0a		 jne	 SHORT $LN23@io_device_

; 427  : 			{
; 428  : 				status = STATUS_DEVICE_NOT_READY;

  00345	bb a3 00 00 c0	 mov	 ebx, -1073741661	; ffffffffc00000a3H

; 429  : 				break;

  0034a	e9 d5 00 00 00	 jmp	 $LN65@io_device_
$LN23@io_device_:

; 430  : 			}
; 431  : 
; 432  : 			PEPROCESS target_proc = NULL;

  0034f	4c 89 7c 24 38	 mov	 QWORD PTR target_proc$2[rsp], r15

; 433  : 			status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)in->pid, &target_proc);

  00354	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00356	48 8d 54 24 38	 lea	 rdx, QWORD PTR target_proc$2[rsp]
  0035b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId
  00361	8b d8		 mov	 ebx, eax
  00363	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 434  : 			if (!NT_SUCCESS(status) || !target_proc)

  00367	85 c0		 test	 eax, eax
  00369	0f 88 b0 00 00
	00		 js	 $LN22@io_device_
  0036f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR target_proc$2[rsp]
  00374	48 85 c9	 test	 rcx, rcx
  00377	0f 84 a2 00 00
	00		 je	 $LN22@io_device_

; 435  : 			{
; 436  : 				status = STATUS_INVALID_PARAMETER;
; 437  : 				break;
; 438  : 			}
; 439  : 
; 440  : 			ObDereferenceObject(target_proc);

  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 441  : 
; 442  : 			SIZE_T CurOffset = 0;

  00383	4d 8b f7	 mov	 r14, r15
  00386	4c 89 7c 24 60	 mov	 QWORD PTR CurOffset$7[rsp], r15

; 443  : 			SIZE_T TotalSize = in->size;

  0038b	48 8b 77 18	 mov	 rsi, QWORD PTR [rdi+24]
  0038f	48 89 74 24 58	 mov	 QWORD PTR TotalSize$6[rsp], rsi
$LL4@io_device_:

; 444  : 
; 445  : 			while (TotalSize > 0)

  00394	48 85 f6	 test	 rsi, rsi
  00397	74 7a		 je	 SHORT $LN28@io_device_

; 446  : 			{
; 447  : 				INT64 CurPhysAddr = TranslateLinearAddress(dirbase, in->src + CurOffset);

  00399	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0039d	49 03 d6	 add	 rdx, r14
  003a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dirbase
  003a7	e8 00 00 00 00	 call	 TranslateLinearAddress
  003ac	4c 8b d0	 mov	 r10, rax

; 448  : 				if (!CurPhysAddr)

  003af	48 85 c0	 test	 rax, rax
  003b2	74 56		 je	 SHORT $LN67@io_device_

; 449  : 				{
; 450  : 					status = STATUS_UNSUCCESSFUL;
; 451  : 					break;
; 452  : 				}
; 453  : 
; 454  : 				ULONG64 ReadSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);

  003b4	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  003b9	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  003be	48 2b c8	 sub	 rcx, rax
  003c1	4c 8b c6	 mov	 r8, rsi
  003c4	48 3b ce	 cmp	 rcx, rsi
  003c7	4c 0f 42 c1	 cmovb	 r8, rcx

; 455  : 				SIZE_T BytesRead = 0;

  003cb	4c 89 7c 24 40	 mov	 QWORD PTR BytesRead$3[rsp], r15

; 456  : 
; 457  : 				status = ReadPhysicalAddress((PVOID)CurPhysAddr, (PVOID)(in->dst + CurOffset), ReadSize, &BytesRead);

  003d0	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  003d4	49 03 d6	 add	 rdx, r14
  003d7	4c 8d 4c 24 40	 lea	 r9, QWORD PTR BytesRead$3[rsp]
  003dc	49 8b ca	 mov	 rcx, r10
  003df	e8 00 00 00 00	 call	 ReadPhysicalAddress
  003e4	8b d8		 mov	 ebx, eax
  003e6	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 458  : 
; 459  : 				if (!NT_SUCCESS(status) || BytesRead == 0)

  003ea	85 c0		 test	 eax, eax
  003ec	78 25		 js	 SHORT $LN28@io_device_
  003ee	48 8b 44 24 40	 mov	 rax, QWORD PTR BytesRead$3[rsp]
  003f3	48 85 c0	 test	 rax, rax
  003f6	74 1b		 je	 SHORT $LN28@io_device_

; 460  : 					break;
; 461  : 
; 462  : 				TotalSize -= BytesRead;

  003f8	48 2b f0	 sub	 rsi, rax
  003fb	48 89 74 24 58	 mov	 QWORD PTR TotalSize$6[rsp], rsi

; 463  : 				CurOffset += BytesRead;

  00400	4c 03 f0	 add	 r14, rax
  00403	4c 89 74 24 60	 mov	 QWORD PTR CurOffset$7[rsp], r14

; 464  : 			}

  00408	eb 8a		 jmp	 SHORT $LL4@io_device_
$LN67@io_device_:

; 565  : 			break;
; 566  : 		}
; 567  : 	}

  0040a	bb 01 00 00 c0	 mov	 ebx, -1073741823	; ffffffffc0000001H
  0040f	89 5c 24 20	 mov	 DWORD PTR status$[rsp], ebx
$LN28@io_device_:
  00413	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  00418	48 89 74 24 28	 mov	 QWORD PTR info_size$[rsp], rsi
  0041d	eb 09		 jmp	 SHORT $LN2@io_device_
$LN22@io_device_:
  0041f	bb 0d 00 00 c0	 mov	 ebx, -1073741811	; ffffffffc000000dH
$LN65@io_device_:
  00424	89 5c 24 20	 mov	 DWORD PTR status$[rsp], ebx
$LN2@io_device_:
  00428	eb 18		 jmp	 SHORT $LN56@io_device_
$LN54@io_device_:

; 568  : 	__except (EXCEPTION_EXECUTE_HANDLER)
; 569  : 	{
; 570  : 		status = STATUS_ACCESS_VIOLATION;

  0042a	bb 05 00 00 c0	 mov	 ebx, -1073741819	; ffffffffc0000005H
  0042f	89 5c 24 20	 mov	 DWORD PTR status$[rsp], ebx

; 571  : 		info_size = 0;

  00433	33 f6		 xor	 esi, esi
  00435	48 89 74 24 28	 mov	 QWORD PTR info_size$[rsp], rsi

; 565  : 			break;
; 566  : 		}
; 567  : 	}

  0043a	4c 8b ac 24 a8
	00 00 00	 mov	 r13, QWORD PTR irp$[rsp]
$LN56@io_device_:

; 572  : 	}
; 573  : 
; 574  : 	irp->IoStatus.Status = status;

  00442	41 89 5d 30	 mov	 DWORD PTR [r13+48], ebx

; 575  : 	irp->IoStatus.Information = info_size;

  00446	49 89 75 38	 mov	 QWORD PTR [r13+56], rsi

; 576  : 	IoCompleteRequest(irp, IO_NO_INCREMENT);

  0044a	33 d2		 xor	 edx, edx
  0044c	49 8b cd	 mov	 rcx, r13
  0044f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 577  : 	return status;

  00455	8b c3		 mov	 eax, ebx
$LN1@io_device_:

; 578  : }

  00457	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  0045f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00463	41 5f		 pop	 r15
  00465	41 5e		 pop	 r14
  00467	41 5d		 pop	 r13
  00469	5f		 pop	 rdi
  0046a	5e		 pop	 rsi
  0046b	c3		 ret	 0
io_device_control ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT dispatch
_TEXT	SEGMENT
device$ = 48
irp$ = 56
dispatch PROC						; COMDAT

; 320  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 321  : 	UNREFERENCED_PARAMETER(device);
; 322  : 
; 323  : 	irp->IoStatus.Status = STATUS_SUCCESS;

  00004	33 c9		 xor	 ecx, ecx
  00006	48 8b c2	 mov	 rax, rdx
  00009	89 4a 30	 mov	 DWORD PTR [rdx+48], ecx

; 324  : 	irp->IoStatus.Information = 0;

  0000c	48 89 4a 38	 mov	 QWORD PTR [rdx+56], rcx

; 325  : 	IoCompleteRequest(irp, IO_NO_INCREMENT);

  00010	33 d2		 xor	 edx, edx
  00012	48 8b c8	 mov	 rcx, rax
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 326  : 	return STATUS_SUCCESS;

  0001b	33 c0		 xor	 eax, eax

; 327  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
dispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT unsupported_dispatch
_TEXT	SEGMENT
device$ = 48
irp$ = 56
unsupported_dispatch PROC				; COMDAT

; 309  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 310  : 	UNREFERENCED_PARAMETER(device);
; 311  : 
; 312  : 	irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
; 313  : 	irp->IoStatus.Information = 0;
; 314  : 	IoCompleteRequest(irp, IO_NO_INCREMENT);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	c7 42 30 bb 00
	00 c0		 mov	 DWORD PTR [rdx+48], -1073741637 ; ffffffffc00000bbH
  0000e	48 c7 42 38 00
	00 00 00	 mov	 QWORD PTR [rdx+56], 0
  00016	33 d2		 xor	 edx, edx
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 315  : 	return STATUS_NOT_SUPPORTED;

  0001e	b8 bb 00 00 c0	 mov	 eax, -1073741637	; ffffffffc00000bbH

; 316  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
unsupported_dispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT get_base_address
_TEXT	SEGMENT
pid$ = 48
target_proc$ = 56
base_address$ = 56
get_base_address PROC					; COMDAT

; 283  : {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 284  : 	if (!base_address)

  0000d	48 85 d2	 test	 rdx, rdx
  00010	74 59		 je	 SHORT $LN4@get_base_a

; 285  : 		return STATUS_INVALID_PARAMETER;
; 286  : 
; 287  : 	*base_address = 0;

  00012	33 c0		 xor	 eax, eax

; 288  : 
; 289  : 	PEPROCESS target_proc = NULL;
; 290  : 	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)pid, &target_proc);

  00014	8b c9		 mov	 ecx, ecx
  00016	48 89 02	 mov	 QWORD PTR [rdx], rax
  00019	48 8d 54 24 38	 lea	 rdx, QWORD PTR target_proc$[rsp]
  0001e	48 89 44 24 38	 mov	 QWORD PTR target_proc$[rsp], rax
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId
  00029	8b d8		 mov	 ebx, eax

; 291  : 
; 292  : 	if (!NT_SUCCESS(status) || !target_proc)

  0002b	85 c0		 test	 eax, eax
  0002d	78 3c		 js	 SHORT $LN4@get_base_a
  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR target_proc$[rsp]
  00034	48 85 c9	 test	 rcx, rcx
  00037	74 32		 je	 SHORT $LN4@get_base_a

; 293  : 		return STATUS_INVALID_PARAMETER;
; 294  : 
; 295  : 	// Get base from EPROCESS
; 296  : 	PVOID base = PsGetProcessSectionBaseAddress(target_proc);

  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsGetProcessSectionBaseAddress

; 297  : 	if (base)

  0003f	48 85 c0	 test	 rax, rax
  00042	74 05		 je	 SHORT $LN5@get_base_a

; 298  : 		*base_address = (ULONG64)base;

  00044	48 89 07	 mov	 QWORD PTR [rdi], rax
  00047	eb 05		 jmp	 SHORT $LN6@get_base_a
$LN5@get_base_a:

; 299  : 	else
; 300  : 		status = STATUS_NOT_FOUND;

  00049	bb 25 02 00 c0	 mov	 ebx, -1073741275	; ffffffffc0000225H
$LN6@get_base_a:

; 301  : 
; 302  : 	ObDereferenceObject(target_proc);

  0004e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR target_proc$[rsp]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 303  : 	RandomDelay();

  00059	e8 00 00 00 00	 call	 RandomDelay

; 304  : 	return status;

  0005e	8b c3		 mov	 eax, ebx

; 305  : }

  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
$LN4@get_base_a:
  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00070	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
get_base_address ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT CleanupThreadRoutine
_TEXT	SEGMENT
context$ = 48
proc$1 = 56
proc$2 = 56
interval$3 = 64
CleanupThreadRoutine PROC				; COMDAT

; 247  : {

$LN34:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 248  : 	UNREFERENCED_PARAMETER(context);
; 249  : 
; 250  : 	while (!should_stop_cleanup)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR should_stop_cleanup, 0
  0000b	0f 85 f5 00 00
	00		 jne	 $LN19@CleanupThr
  00011	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00016	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0001b	33 ff		 xor	 edi, edi
  0001d	0f 1f 00	 npad	 3
$LL2@CleanupThr:

; 251  : 	{
; 252  : 		// Sleep for 5 seconds
; 253  : 		LARGE_INTEGER interval;
; 254  : 		interval.QuadPart = -(50000000LL); // 5 seconds
; 255  : 		KeDelayExecutionThread(KernelMode, FALSE, &interval);

  00020	4c 8d 44 24 40	 lea	 r8, QWORD PTR interval$3[rsp]
  00025	48 c7 44 24 40
	80 0f 05 fd	 mov	 QWORD PTR interval$3[rsp], -50000000 ; fffffffffd050f80H
  0002e	33 d2		 xor	 edx, edx
  00030	33 c9		 xor	 ecx, ecx
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeDelayExecutionThread

; 256  : 
; 257  : 		// Check if both processes are dead
; 258  : 		BOOLEAN cs2_alive = IsProcessAlive(monitored_cs2_pid);

  00038	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR monitored_cs2_pid

; 230  : 	if (!pid)

  0003e	85 c0		 test	 eax, eax
  00040	74 2a		 je	 SHORT $LN10@CleanupThr

; 231  : 		return FALSE;
; 232  : 
; 233  : 	PEPROCESS proc = NULL;
; 234  : 	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)pid, &proc);

  00042	8b c8		 mov	 ecx, eax
  00044	48 89 7c 24 38	 mov	 QWORD PTR proc$2[rsp], rdi
  00049	48 8d 54 24 38	 lea	 rdx, QWORD PTR proc$2[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId

; 235  : 
; 236  : 	if (NT_SUCCESS(status) && proc)

  00054	85 c0		 test	 eax, eax
  00056	78 14		 js	 SHORT $LN10@CleanupThr
  00058	48 8b 4c 24 38	 mov	 rcx, QWORD PTR proc$2[rsp]
  0005d	48 85 c9	 test	 rcx, rcx
  00060	74 0a		 je	 SHORT $LN10@CleanupThr

; 237  : 	{
; 238  : 		ObDereferenceObject(proc);

  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 239  : 		return TRUE;

  00068	b3 01		 mov	 bl, 1
  0006a	eb 02		 jmp	 SHORT $LN8@CleanupThr
$LN10@CleanupThr:

; 259  : 		BOOLEAN cheat_alive = IsProcessAlive(monitored_cheat_pid);

  0006c	32 db		 xor	 bl, bl
$LN8@CleanupThr:
  0006e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR monitored_cheat_pid

; 230  : 	if (!pid)

  00074	85 c0		 test	 eax, eax
  00076	74 2a		 je	 SHORT $LN14@CleanupThr

; 231  : 		return FALSE;
; 232  : 
; 233  : 	PEPROCESS proc = NULL;
; 234  : 	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)pid, &proc);

  00078	8b c8		 mov	 ecx, eax
  0007a	48 89 7c 24 38	 mov	 QWORD PTR proc$1[rsp], rdi
  0007f	48 8d 54 24 38	 lea	 rdx, QWORD PTR proc$1[rsp]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId

; 235  : 
; 236  : 	if (NT_SUCCESS(status) && proc)

  0008a	85 c0		 test	 eax, eax
  0008c	78 14		 js	 SHORT $LN14@CleanupThr
  0008e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR proc$1[rsp]
  00093	48 85 c9	 test	 rcx, rcx
  00096	74 0a		 je	 SHORT $LN14@CleanupThr

; 237  : 	{
; 238  : 		ObDereferenceObject(proc);

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 239  : 		return TRUE;

  0009e	b0 01		 mov	 al, 1
  000a0	eb 02		 jmp	 SHORT $LN12@CleanupThr
$LN14@CleanupThr:

; 260  : 
; 261  : 		if (!cs2_alive && !cheat_alive && (monitored_cs2_pid != 0 || monitored_cheat_pid != 0))

  000a2	32 c0		 xor	 al, al
$LN12@CleanupThr:
  000a4	84 db		 test	 bl, bl
  000a6	75 14		 jne	 SHORT $LN4@CleanupThr
  000a8	84 c0		 test	 al, al
  000aa	75 10		 jne	 SHORT $LN4@CleanupThr
  000ac	39 3d 00 00 00
	00		 cmp	 DWORD PTR monitored_cs2_pid, edi
  000b2	75 17		 jne	 SHORT $LN5@CleanupThr
  000b4	39 3d 00 00 00
	00		 cmp	 DWORD PTR monitored_cheat_pid, edi
  000ba	75 0f		 jne	 SHORT $LN5@CleanupThr
$LN4@CleanupThr:

; 248  : 	UNREFERENCED_PARAMETER(context);
; 249  : 
; 250  : 	while (!should_stop_cleanup)

  000bc	40 38 3d 00 00
	00 00		 cmp	 BYTE PTR should_stop_cleanup, dil
  000c3	0f 84 57 ff ff
	ff		 je	 $LL2@CleanupThr
  000c9	eb 31		 jmp	 SHORT $LN32@CleanupThr
$LN5@CleanupThr:

; 262  : 		{
; 263  : 			// Both processes are dead, unload driver
; 264  : 			should_stop_cleanup = TRUE;
; 265  : 
; 266  : 			// Cleanup device
; 267  : 			if (driver_object)

  000cb	48 39 3d 00 00
	00 00		 cmp	 QWORD PTR driver_object, rdi
  000d2	c6 05 00 00 00
	00 01		 mov	 BYTE PTR should_stop_cleanup, 1
  000d9	74 21		 je	 SHORT $LN32@CleanupThr

; 268  : 			{
; 269  : 				IoDeleteSymbolicLink(&dos);

  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 270  : 				IoDeleteDevice(driver_object);

  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR driver_object
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 271  : 				driver_object = NULL;

  000f5	48 89 3d 00 00
	00 00		 mov	 QWORD PTR driver_object, rdi
$LN32@CleanupThr:
  000fc	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00101	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
$LN19@CleanupThr:

; 272  : 			}
; 273  : 
; 274  : 			break;
; 275  : 		}
; 276  : 	}
; 277  : 
; 278  : 	PsTerminateSystemThread(STATUS_SUCCESS);

  00106	33 c9		 xor	 ecx, ecx

; 279  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 272  : 			}
; 273  : 
; 274  : 			break;
; 275  : 		}
; 276  : 	}
; 277  : 
; 278  : 	PsTerminateSystemThread(STATUS_SUCCESS);

  0010c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_PsTerminateSystemThread
CleanupThreadRoutine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT IsProcessAlive
_TEXT	SEGMENT
pid$ = 48
proc$ = 56
IsProcessAlive PROC					; COMDAT

; 229  : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 230  : 	if (!pid)

  00004	85 c9		 test	 ecx, ecx
  00006	74 31		 je	 SHORT $LN3@IsProcessA

; 231  : 		return FALSE;
; 232  : 
; 233  : 	PEPROCESS proc = NULL;
; 234  : 	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)pid, &proc);

  00008	8b c9		 mov	 ecx, ecx
  0000a	48 8d 54 24 38	 lea	 rdx, QWORD PTR proc$[rsp]
  0000f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR proc$[rsp], 0
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId

; 235  : 
; 236  : 	if (NT_SUCCESS(status) && proc)

  0001e	85 c0		 test	 eax, eax
  00020	78 17		 js	 SHORT $LN3@IsProcessA
  00022	48 8b 4c 24 38	 mov	 rcx, QWORD PTR proc$[rsp]
  00027	48 85 c9	 test	 rcx, rcx
  0002a	74 0d		 je	 SHORT $LN3@IsProcessA

; 237  : 	{
; 238  : 		ObDereferenceObject(proc);

  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 239  : 		return TRUE;

  00032	b0 01		 mov	 al, 1

; 243  : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN3@IsProcessA:

; 240  : 	}
; 241  : 
; 242  : 	return FALSE;

  00039	32 c0		 xor	 al, al

; 243  : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
IsProcessAlive ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT TranslateLinearAddress
_TEXT	SEGMENT
pte$ = 48
BytesCopied$1 = 56
BytesCopied$2 = 56
BytesCopied$3 = 56
BytesCopied$4 = 56
name$5 = 64
name$6 = 64
name$7 = 64
name$8 = 64
pml4e$ = 144
directoryTableBase$ = 144
virtualAddress$ = 152
pdpte$ = 160
pde$ = 168
TranslateLinearAddress PROC				; COMDAT

; 172  : {

$LN88:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8b ec	 mov	 rbp, rsp
  00013	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00017	48 8b fa	 mov	 rdi, rdx

; 173  : 	if (!directoryTableBase || !virtualAddress)

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	0f 84 cf 02 00
	00		 je	 $LN3@TranslateL
  00023	48 85 d2	 test	 rdx, rdx
  00026	0f 84 c6 02 00
	00		 je	 $LN3@TranslateL

; 175  : 
; 176  : 	// Cast to ULONG64 for pointer arithmetic
; 177  : 	ULONG64 va = virtualAddress;
; 178  : 	
; 179  : 	// Extract page table indices
; 180  : 	ULONG64 pml4_index = (va >> 39) & 0x1FF;
; 181  : 	ULONG64 pdpt_index = (va >> 30) & 0x1FF;
; 182  : 	ULONG64 pd_index = (va >> 21) & 0x1FF;
; 183  : 	ULONG64 pt_index = (va >> 12) & 0x1FF;
; 184  : 	ULONG64 offset = va & 0xFFF;
; 185  : 
; 186  : 	// Read PML4E
; 187  : 	ULONG64 pml4e = 0;

  0002c	45 33 ed	 xor	 r13d, r13d
  0002f	48 8b c2	 mov	 rax, rdx
  00032	48 c1 e8 27	 shr	 rax, 39			; 00000027H
  00036	48 8b f2	 mov	 rsi, rdx
  00039	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  0003e	48 c1 ee 1e	 shr	 rsi, 30
  00042	4c 8b f2	 mov	 r14, rdx
  00045	4c 89 6d 40	 mov	 QWORD PTR pml4e$[rbp-80], r13
  00049	49 c1 ee 15	 shr	 r14, 21
  0004d	4c 8b fa	 mov	 r15, rdx
  00050	49 c1 ef 0c	 shr	 r15, 12
  00054	4c 8b e2	 mov	 r12, rdx

; 188  : 	SIZE_T readSize = 0;
; 189  : 	if (!NT_SUCCESS(ReadPhysicalAddress(
; 190  : 		(PVOID)(directoryTableBase + pml4_index * sizeof(ULONG64)),
; 191  : 		&pml4e, sizeof(pml4e), &readSize)) || !pml4e || !(pml4e & 1))

  00057	48 8d 1c c1	 lea	 rbx, QWORD PTR [rcx+rax*8]
  0005b	81 e6 ff 01 00
	00		 and	 esi, 511		; 000001ffH
  00061	41 81 e6 ff 01
	00 00		 and	 r14d, 511		; 000001ffH
  00068	41 81 e7 ff 01
	00 00		 and	 r15d, 511		; 000001ffH
  0006f	41 81 e4 ff 0f
	00 00		 and	 r12d, 4095		; 00000fffH

; 108  : 	if (!TargetAddress || !lpBuffer || !BytesRead)

  00076	48 81 fb 00 10
	00 00		 cmp	 rbx, 4096		; 00001000H
  0007d	0f 82 6f 02 00
	00		 jb	 $LN3@TranslateL

; 109  : 		return STATUS_INVALID_PARAMETER;
; 110  : 
; 111  : 	if ((ULONG64)TargetAddress < 0x1000)
; 112  : 		return STATUS_ACCESS_VIOLATION;
; 113  : 
; 114  : 	*BytesRead = 0;
; 115  : 
; 116  : 	if (!pMmCopyMemory)

  00083	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pMmCopyMemory
  0008a	48 85 c0	 test	 rax, rax
  0008d	75 2b		 jne	 SHORT $LN20@TranslateL

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@
  00096	48 8d 4d f0	 lea	 rcx, QWORD PTR name$8[rbp-80]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 85   : 	
; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  000a0	48 8d 4d f0	 lea	 rcx, QWORD PTR name$8[rbp-80]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress

; 117  : 		pMmCopyMemory = (fnMmCopyMemory)GetKernelFunction((PUCHAR)"MmCopyMemory");

  000aa	48 89 05 00 00
	00 00		 mov	 QWORD PTR pMmCopyMemory, rax
  000b1	48 85 c0	 test	 rax, rax

; 118  : 
; 119  : 	if (!pMmCopyMemory)

  000b4	0f 84 38 02 00
	00		 je	 $LN3@TranslateL
$LN20@TranslateL:

; 126  : 	NTSTATUS status = pMmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, &BytesCopied);

  000ba	41 b9 01 00 00
	00		 mov	 r9d, 1
  000c0	4c 89 6d e8	 mov	 QWORD PTR BytesCopied$4[rbp-80], r13
  000c4	48 8d 4d e8	 lea	 rcx, QWORD PTR BytesCopied$4[rbp-80]
  000c8	48 8b d3	 mov	 rdx, rbx
  000cb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000d0	48 8d 4d 40	 lea	 rcx, QWORD PTR pml4e$[rbp-80]
  000d4	45 8d 41 07	 lea	 r8d, QWORD PTR [r9+7]
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr
  000de	8b d8		 mov	 ebx, eax

; 127  : 
; 128  : 	if (NT_SUCCESS(status))
; 129  : 		*BytesRead = BytesCopied;
; 130  : 
; 131  : 	RandomDelay();

  000e0	e8 00 00 00 00	 call	 RandomDelay

; 188  : 	SIZE_T readSize = 0;
; 189  : 	if (!NT_SUCCESS(ReadPhysicalAddress(
; 190  : 		(PVOID)(directoryTableBase + pml4_index * sizeof(ULONG64)),
; 191  : 		&pml4e, sizeof(pml4e), &readSize)) || !pml4e || !(pml4e & 1))

  000e5	85 db		 test	 ebx, ebx
  000e7	0f 88 05 02 00
	00		 js	 $LN3@TranslateL
  000ed	48 8b 45 40	 mov	 rax, QWORD PTR pml4e$[rbp-80]
  000f1	48 85 c0	 test	 rax, rax
  000f4	0f 84 f8 01 00
	00		 je	 $LN3@TranslateL
  000fa	a8 01		 test	 al, 1
  000fc	0f 84 f0 01 00
	00		 je	 $LN3@TranslateL

; 192  : 		return 0;
; 193  : 
; 194  : 	// Read PDPTE
; 195  : 	ULONG64 pdpte = 0;

  00102	4c 89 6d 50	 mov	 QWORD PTR pdpte$[rbp-80], r13

; 196  : 	if (!NT_SUCCESS(ReadPhysicalAddress(
; 197  : 		(PVOID)((pml4e & PMASK) + pdpt_index * sizeof(ULONG64)),
; 198  : 		&pdpte, sizeof(pdpte), &readSize)) || !pdpte || !(pdpte & 1))

  00106	49 bd 00 f0 ff
	ff ff ff 0f 00	 mov	 r13, 4503599627366400	; 000ffffffffff000H
  00110	49 23 c5	 and	 rax, r13
  00113	48 8d 1c f0	 lea	 rbx, QWORD PTR [rax+rsi*8]

; 108  : 	if (!TargetAddress || !lpBuffer || !BytesRead)

  00117	48 81 fb 00 10
	00 00		 cmp	 rbx, 4096		; 00001000H
  0011e	0f 82 ce 01 00
	00		 jb	 $LN3@TranslateL

; 109  : 		return STATUS_INVALID_PARAMETER;
; 110  : 
; 111  : 	if ((ULONG64)TargetAddress < 0x1000)
; 112  : 		return STATUS_ACCESS_VIOLATION;
; 113  : 
; 114  : 	*BytesRead = 0;
; 115  : 
; 116  : 	if (!pMmCopyMemory)

  00124	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pMmCopyMemory
  0012b	48 85 c0	 test	 rax, rax
  0012e	75 2b		 jne	 SHORT $LN30@TranslateL

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@
  00137	48 8d 4d f0	 lea	 rcx, QWORD PTR name$7[rbp-80]
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 85   : 	
; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  00141	48 8d 4d f0	 lea	 rcx, QWORD PTR name$7[rbp-80]
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress

; 117  : 		pMmCopyMemory = (fnMmCopyMemory)GetKernelFunction((PUCHAR)"MmCopyMemory");

  0014b	48 89 05 00 00
	00 00		 mov	 QWORD PTR pMmCopyMemory, rax
  00152	48 85 c0	 test	 rax, rax

; 118  : 
; 119  : 	if (!pMmCopyMemory)

  00155	0f 84 97 01 00
	00		 je	 $LN3@TranslateL
$LN30@TranslateL:

; 120  : 		return STATUS_NOT_FOUND;
; 121  : 
; 122  : 	MM_COPY_ADDRESS AddrToRead = { 0 };
; 123  : 	AddrToRead.PhysicalAddress.QuadPart = (LONGLONG)TargetAddress;
; 124  : 
; 125  : 	SIZE_T BytesCopied = 0;

  0015b	33 f6		 xor	 esi, esi

; 126  : 	NTSTATUS status = pMmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, &BytesCopied);

  0015d	48 8d 4d e8	 lea	 rcx, QWORD PTR BytesCopied$3[rbp-80]
  00161	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00166	48 8b d3	 mov	 rdx, rbx
  00169	48 8d 4d 50	 lea	 rcx, QWORD PTR pdpte$[rbp-80]
  0016d	48 89 75 e8	 mov	 QWORD PTR BytesCopied$3[rbp-80], rsi
  00171	44 8d 4e 01	 lea	 r9d, QWORD PTR [rsi+1]
  00175	44 8d 46 08	 lea	 r8d, QWORD PTR [rsi+8]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr
  0017f	8b d8		 mov	 ebx, eax

; 127  : 
; 128  : 	if (NT_SUCCESS(status))
; 129  : 		*BytesRead = BytesCopied;
; 130  : 
; 131  : 	RandomDelay();

  00181	e8 00 00 00 00	 call	 RandomDelay

; 196  : 	if (!NT_SUCCESS(ReadPhysicalAddress(
; 197  : 		(PVOID)((pml4e & PMASK) + pdpt_index * sizeof(ULONG64)),
; 198  : 		&pdpte, sizeof(pdpte), &readSize)) || !pdpte || !(pdpte & 1))

  00186	85 db		 test	 ebx, ebx
  00188	0f 88 64 01 00
	00		 js	 $LN3@TranslateL
  0018e	48 8b 45 50	 mov	 rax, QWORD PTR pdpte$[rbp-80]
  00192	48 85 c0	 test	 rax, rax
  00195	0f 84 57 01 00
	00		 je	 $LN3@TranslateL
  0019b	a8 01		 test	 al, 1
  0019d	0f 84 4f 01 00
	00		 je	 $LN3@TranslateL

; 199  : 		return 0;
; 200  : 
; 201  : 	// Check for 1GB page
; 202  : 	if (pdpte & 0x80)

  001a3	84 c0		 test	 al, al
  001a5	79 14		 jns	 SHORT $LN8@TranslateL

; 203  : 		return (pdpte & (~0ull << 30)) + (va & ~(~0ull << 30));

  001a7	48 25 00 00 00
	c0		 and	 rax, -1073741824	; ffffffffc0000000H
  001ad	81 e7 ff ff ff
	3f		 and	 edi, 1073741823		; 3fffffffH
  001b3	48 03 c7	 add	 rax, rdi
  001b6	e9 39 01 00 00	 jmp	 $LN1@TranslateL
$LN8@TranslateL:

; 204  : 
; 205  : 	// Read PDE
; 206  : 	ULONG64 pde = 0;
; 207  : 	if (!NT_SUCCESS(ReadPhysicalAddress(
; 208  : 		(PVOID)((pdpte & PMASK) + pd_index * sizeof(ULONG64)),
; 209  : 		&pde, sizeof(pde), &readSize)) || !pde || !(pde & 1))

  001bb	49 23 c5	 and	 rax, r13
  001be	48 89 75 58	 mov	 QWORD PTR pde$[rbp-80], rsi
  001c2	4a 8d 1c f0	 lea	 rbx, QWORD PTR [rax+r14*8]

; 108  : 	if (!TargetAddress || !lpBuffer || !BytesRead)

  001c6	48 81 fb 00 10
	00 00		 cmp	 rbx, 4096		; 00001000H
  001cd	0f 82 1f 01 00
	00		 jb	 $LN3@TranslateL

; 109  : 		return STATUS_INVALID_PARAMETER;
; 110  : 
; 111  : 	if ((ULONG64)TargetAddress < 0x1000)
; 112  : 		return STATUS_ACCESS_VIOLATION;
; 113  : 
; 114  : 	*BytesRead = 0;
; 115  : 
; 116  : 	if (!pMmCopyMemory)

  001d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pMmCopyMemory
  001da	48 85 c0	 test	 rax, rax
  001dd	75 2b		 jne	 SHORT $LN40@TranslateL

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@
  001e6	48 8d 4d f0	 lea	 rcx, QWORD PTR name$6[rbp-80]
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 85   : 	
; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  001f0	48 8d 4d f0	 lea	 rcx, QWORD PTR name$6[rbp-80]
  001f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress

; 117  : 		pMmCopyMemory = (fnMmCopyMemory)GetKernelFunction((PUCHAR)"MmCopyMemory");

  001fa	48 89 05 00 00
	00 00		 mov	 QWORD PTR pMmCopyMemory, rax
  00201	48 85 c0	 test	 rax, rax

; 118  : 
; 119  : 	if (!pMmCopyMemory)

  00204	0f 84 e8 00 00
	00		 je	 $LN3@TranslateL
$LN40@TranslateL:

; 126  : 	NTSTATUS status = pMmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, &BytesCopied);

  0020a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00210	48 89 75 e8	 mov	 QWORD PTR BytesCopied$2[rbp-80], rsi
  00214	48 8d 4d e8	 lea	 rcx, QWORD PTR BytesCopied$2[rbp-80]
  00218	48 8b d3	 mov	 rdx, rbx
  0021b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00220	48 8d 4d 58	 lea	 rcx, QWORD PTR pde$[rbp-80]
  00224	45 8d 41 07	 lea	 r8d, QWORD PTR [r9+7]
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr
  0022e	8b d8		 mov	 ebx, eax

; 127  : 
; 128  : 	if (NT_SUCCESS(status))
; 129  : 		*BytesRead = BytesCopied;
; 130  : 
; 131  : 	RandomDelay();

  00230	e8 00 00 00 00	 call	 RandomDelay

; 204  : 
; 205  : 	// Read PDE
; 206  : 	ULONG64 pde = 0;
; 207  : 	if (!NT_SUCCESS(ReadPhysicalAddress(
; 208  : 		(PVOID)((pdpte & PMASK) + pd_index * sizeof(ULONG64)),
; 209  : 		&pde, sizeof(pde), &readSize)) || !pde || !(pde & 1))

  00235	85 db		 test	 ebx, ebx
  00237	0f 88 b5 00 00
	00		 js	 $LN3@TranslateL
  0023d	48 8b 45 58	 mov	 rax, QWORD PTR pde$[rbp-80]
  00241	48 85 c0	 test	 rax, rax
  00244	0f 84 a8 00 00
	00		 je	 $LN3@TranslateL
  0024a	a8 01		 test	 al, 1
  0024c	0f 84 a0 00 00
	00		 je	 $LN3@TranslateL

; 210  : 		return 0;
; 211  : 
; 212  : 	// Check for 2MB page
; 213  : 	if (pde & 0x80)

  00252	84 c0		 test	 al, al
  00254	79 11		 jns	 SHORT $LN11@TranslateL

; 214  : 		return (pde & PMASK) + (va & ~(~0ull << 21));

  00256	49 23 c5	 and	 rax, r13
  00259	81 e7 ff ff 1f
	00		 and	 edi, 2097151		; 001fffffH
  0025f	48 03 c7	 add	 rax, rdi
  00262	e9 8d 00 00 00	 jmp	 $LN1@TranslateL
$LN11@TranslateL:

; 215  : 
; 216  : 	// Read PTE
; 217  : 	ULONG64 pte = 0;
; 218  : 	if (!NT_SUCCESS(ReadPhysicalAddress(
; 219  : 		(PVOID)((pde & PMASK) + pt_index * sizeof(ULONG64)),
; 220  : 		&pte, sizeof(pte), &readSize)) || !pte || !(pte & 1))

  00267	49 23 c5	 and	 rax, r13
  0026a	48 89 75 e0	 mov	 QWORD PTR pte$[rbp-80], rsi
  0026e	4a 8d 1c f8	 lea	 rbx, QWORD PTR [rax+r15*8]

; 108  : 	if (!TargetAddress || !lpBuffer || !BytesRead)

  00272	48 81 fb 00 10
	00 00		 cmp	 rbx, 4096		; 00001000H
  00279	72 77		 jb	 SHORT $LN3@TranslateL

; 109  : 		return STATUS_INVALID_PARAMETER;
; 110  : 
; 111  : 	if ((ULONG64)TargetAddress < 0x1000)
; 112  : 		return STATUS_ACCESS_VIOLATION;
; 113  : 
; 114  : 	*BytesRead = 0;
; 115  : 
; 116  : 	if (!pMmCopyMemory)

  0027b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pMmCopyMemory
  00282	48 85 c0	 test	 rax, rax
  00285	75 27		 jne	 SHORT $LN50@TranslateL

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  00287	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@
  0028e	48 8d 4d f0	 lea	 rcx, QWORD PTR name$5[rbp-80]
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 85   : 	
; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  00298	48 8d 4d f0	 lea	 rcx, QWORD PTR name$5[rbp-80]
  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress

; 117  : 		pMmCopyMemory = (fnMmCopyMemory)GetKernelFunction((PUCHAR)"MmCopyMemory");

  002a2	48 89 05 00 00
	00 00		 mov	 QWORD PTR pMmCopyMemory, rax
  002a9	48 85 c0	 test	 rax, rax

; 118  : 
; 119  : 	if (!pMmCopyMemory)

  002ac	74 44		 je	 SHORT $LN3@TranslateL
$LN50@TranslateL:

; 126  : 	NTSTATUS status = pMmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, &BytesCopied);

  002ae	41 b9 01 00 00
	00		 mov	 r9d, 1
  002b4	48 89 75 e8	 mov	 QWORD PTR BytesCopied$1[rbp-80], rsi
  002b8	48 8d 4d e8	 lea	 rcx, QWORD PTR BytesCopied$1[rbp-80]
  002bc	48 8b d3	 mov	 rdx, rbx
  002bf	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002c4	48 8d 4d e0	 lea	 rcx, QWORD PTR pte$[rbp-80]
  002c8	45 8d 41 07	 lea	 r8d, QWORD PTR [r9+7]
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr
  002d2	8b d8		 mov	 ebx, eax

; 127  : 
; 128  : 	if (NT_SUCCESS(status))
; 129  : 		*BytesRead = BytesCopied;
; 130  : 
; 131  : 	RandomDelay();

  002d4	e8 00 00 00 00	 call	 RandomDelay

; 215  : 
; 216  : 	// Read PTE
; 217  : 	ULONG64 pte = 0;
; 218  : 	if (!NT_SUCCESS(ReadPhysicalAddress(
; 219  : 		(PVOID)((pde & PMASK) + pt_index * sizeof(ULONG64)),
; 220  : 		&pte, sizeof(pte), &readSize)) || !pte || !(pte & 1))

  002d9	85 db		 test	 ebx, ebx
  002db	78 15		 js	 SHORT $LN3@TranslateL
  002dd	48 8b 45 e0	 mov	 rax, QWORD PTR pte$[rbp-80]
  002e1	48 85 c0	 test	 rax, rax
  002e4	74 0c		 je	 SHORT $LN3@TranslateL
  002e6	a8 01		 test	 al, 1
  002e8	74 08		 je	 SHORT $LN3@TranslateL

; 221  : 		return 0;
; 222  : 
; 223  : 	// Return physical address
; 224  : 	return (pte & PMASK) + offset;

  002ea	49 23 c5	 and	 rax, r13
  002ed	49 03 c4	 add	 rax, r12
  002f0	eb 02		 jmp	 SHORT $LN1@TranslateL
$LN3@TranslateL:

; 174  : 		return 0;

  002f2	33 c0		 xor	 eax, eax
$LN1@TranslateL:

; 225  : }

  002f4	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  002fc	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00300	41 5f		 pop	 r15
  00302	41 5e		 pop	 r14
  00304	41 5d		 pop	 r13
  00306	41 5c		 pop	 r12
  00308	5f		 pop	 rdi
  00309	5e		 pop	 rsi
  0030a	5d		 pop	 rbp
  0030b	c3		 ret	 0
TranslateLinearAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT WritePhysicalAddress
_TEXT	SEGMENT
pmapped_mem$ = 64
TargetAddress$ = 64
lpBuffer$ = 72
Size$ = 80
BytesWritten$ = 88
WritePhysicalAddress PROC				; COMDAT

; 137  : {

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	49 8b f1	 mov	 rsi, r9
  00015	49 8b d8	 mov	 rbx, r8
  00018	4c 8b f2	 mov	 r14, rdx

; 138  : 	if (!TargetAddress || !lpBuffer || !BytesWritten)

  0001b	48 85 c9	 test	 rcx, rcx
  0001e	0f 84 b7 00 00
	00		 je	 $LN3@WritePhysi
  00024	48 85 d2	 test	 rdx, rdx
  00027	0f 84 ae 00 00
	00		 je	 $LN3@WritePhysi
  0002d	4d 85 c9	 test	 r9, r9
  00030	0f 84 a5 00 00
	00		 je	 $LN3@WritePhysi

; 140  : 
; 141  : 	if ((ULONG64)TargetAddress < 0x1000 || (ULONG64)TargetAddress > 0x7FFFFFFFFFFF)

  00036	48 8d 81 00 f0
	ff ff		 lea	 rax, QWORD PTR [rcx-4096]
  0003d	48 ba ff ef ff
	ff ff 7f 00 00	 mov	 rdx, 140737488351231	; 00007fffffffefffH
  00047	48 3b c2	 cmp	 rax, rdx
  0004a	77 7c		 ja	 SHORT $LN5@WritePhysi

; 143  : 
; 144  : 	*BytesWritten = 0;

  0004c	49 c7 01 00 00
	00 00		 mov	 QWORD PTR [r9], 0

; 145  : 
; 146  : 	PHYSICAL_ADDRESS AddrToWrite = { 0 };
; 147  : 	AddrToWrite.QuadPart = (LONGLONG)TargetAddress;
; 148  : 
; 149  : 	PVOID pmapped_mem = MmMapIoSpace(AddrToWrite, Size, MmNonCached);

  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b d3	 mov	 rdx, rbx
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapIoSpace
  0005f	48 8b f8	 mov	 rdi, rax
  00062	48 89 44 24 40	 mov	 QWORD PTR pmapped_mem$[rsp], rax

; 150  : 	if (!pmapped_mem)

  00067	48 85 c0	 test	 rax, rax
  0006a	75 13		 jne	 SHORT $LN6@WritePhysi

; 151  : 		return STATUS_UNSUCCESSFUL;

  0006c	b8 01 00 00 c0	 mov	 eax, -1073741823	; ffffffffc0000001H

; 168  : }

  00071	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	41 5e		 pop	 r14
  0007c	5f		 pop	 rdi
  0007d	5e		 pop	 rsi
  0007e	c3		 ret	 0
$LN6@WritePhysi:

; 152  : 
; 153  : 	__try
; 154  : 	{
; 155  : 		// Use RtlCopyMemory with SEH
; 156  : 		RtlCopyMemory(pmapped_mem, lpBuffer, Size);

  0007f	4c 8b c3	 mov	 r8, rbx
  00082	49 8b d6	 mov	 rdx, r14
  00085	48 8b cf	 mov	 rcx, rdi
  00088	e8 00 00 00 00	 call	 memcpy

; 157  : 		*BytesWritten = Size;

  0008d	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 163  : 	}
; 164  : 
; 165  : 	MmUnmapIoSpace(pmapped_mem, Size);

  00090	48 8b d3	 mov	 rdx, rbx
  00093	48 8b cf	 mov	 rcx, rdi
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnmapIoSpace

; 166  : 	RandomDelay();

  0009c	e8 00 00 00 00	 call	 RandomDelay

; 167  : 	return STATUS_SUCCESS;

  000a1	33 c0		 xor	 eax, eax

; 168  : }

  000a3	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ac	41 5e		 pop	 r14
  000ae	5f		 pop	 rdi
  000af	5e		 pop	 rsi
  000b0	c3		 ret	 0
$LN11@WritePhysi:

; 158  : 	}
; 159  : 	__except (EXCEPTION_EXECUTE_HANDLER)
; 160  : 	{
; 161  : 		MmUnmapIoSpace(pmapped_mem, Size);

  000b1	48 8b 54 24 50	 mov	 rdx, QWORD PTR Size$[rsp]
  000b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pmapped_mem$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnmapIoSpace

; 162  : 		return STATUS_ACCESS_VIOLATION;

  000c1	b8 05 00 00 c0	 mov	 eax, -1073741819	; ffffffffc0000005H
  000c6	eb 18		 jmp	 SHORT $LN1@WritePhysi
$LN5@WritePhysi:

; 142  : 		return STATUS_ACCESS_VIOLATION;

  000c8	b8 05 00 00 c0	 mov	 eax, -1073741819	; ffffffffc0000005H

; 168  : }

  000cd	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	41 5e		 pop	 r14
  000d8	5f		 pop	 rdi
  000d9	5e		 pop	 rsi
  000da	c3		 ret	 0
$LN3@WritePhysi:

; 139  : 		return STATUS_INVALID_PARAMETER;

  000db	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
$LN1@WritePhysi:

; 168  : }

  000e0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000e5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e9	41 5e		 pop	 r14
  000eb	5f		 pop	 rdi
  000ec	5e		 pop	 rsi
  000ed	c3		 ret	 0
WritePhysicalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT ReadPhysicalAddress
_TEXT	SEGMENT
name$1 = 48
BytesCopied$ = 80
TargetAddress$ = 80
lpBuffer$ = 88
Size$ = 96
BytesRead$ = 104
ReadPhysicalAddress PROC				; COMDAT

; 107  : {

$LN19:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	49 8b d9	 mov	 rbx, r9
  00017	49 8b e8	 mov	 rbp, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	48 8b f9	 mov	 rdi, rcx

; 108  : 	if (!TargetAddress || !lpBuffer || !BytesRead)

  00020	48 85 c9	 test	 rcx, rcx
  00023	0f 84 a7 00 00
	00		 je	 $LN3@ReadPhysic
  00029	48 85 d2	 test	 rdx, rdx
  0002c	0f 84 9e 00 00
	00		 je	 $LN3@ReadPhysic
  00032	48 85 db	 test	 rbx, rbx
  00035	0f 84 95 00 00
	00		 je	 $LN3@ReadPhysic

; 110  : 
; 111  : 	if ((ULONG64)TargetAddress < 0x1000)

  0003b	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00042	73 0a		 jae	 SHORT $LN4@ReadPhysic

; 112  : 		return STATUS_ACCESS_VIOLATION;

  00044	b8 05 00 00 c0	 mov	 eax, -1073741819	; ffffffffc0000005H
  00049	e9 87 00 00 00	 jmp	 $LN1@ReadPhysic
$LN4@ReadPhysic:

; 113  : 
; 114  : 	*BytesRead = 0;

  0004e	49 c7 01 00 00
	00 00		 mov	 QWORD PTR [r9], 0

; 115  : 
; 116  : 	if (!pMmCopyMemory)

  00055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pMmCopyMemory
  0005c	48 85 c0	 test	 rax, rax
  0005f	75 30		 jne	 SHORT $LN6@ReadPhysic

; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EGKHOMEL@MmCopyMemory@FNODOBFM@
  00068	48 8d 4c 24 30	 lea	 rcx, QWORD PTR name$1[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 85   : 	
; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  00073	48 8d 4c 24 30	 lea	 rcx, QWORD PTR name$1[rsp]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress

; 117  : 		pMmCopyMemory = (fnMmCopyMemory)GetKernelFunction((PUCHAR)"MmCopyMemory");

  0007e	48 89 05 00 00
	00 00		 mov	 QWORD PTR pMmCopyMemory, rax
  00085	48 85 c0	 test	 rax, rax

; 118  : 
; 119  : 	if (!pMmCopyMemory)

  00088	75 07		 jne	 SHORT $LN6@ReadPhysic

; 120  : 		return STATUS_NOT_FOUND;

  0008a	b8 25 02 00 c0	 mov	 eax, -1073741275	; ffffffffc0000225H
  0008f	eb 44		 jmp	 SHORT $LN1@ReadPhysic
$LN6@ReadPhysic:

; 121  : 
; 122  : 	MM_COPY_ADDRESS AddrToRead = { 0 };
; 123  : 	AddrToRead.PhysicalAddress.QuadPart = (LONGLONG)TargetAddress;
; 124  : 
; 125  : 	SIZE_T BytesCopied = 0;
; 126  : 	NTSTATUS status = pMmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, &BytesCopied);

  00091	48 8d 4c 24 50	 lea	 rcx, QWORD PTR BytesCopied$[rsp]
  00096	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR BytesCopied$[rsp], 0
  0009f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000a4	41 b9 01 00 00
	00		 mov	 r9d, 1
  000aa	48 8b ce	 mov	 rcx, rsi
  000ad	4c 8b c5	 mov	 r8, rbp
  000b0	48 8b d7	 mov	 rdx, rdi
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr
  000b9	8b f8		 mov	 edi, eax

; 127  : 
; 128  : 	if (NT_SUCCESS(status))

  000bb	85 c0		 test	 eax, eax
  000bd	78 08		 js	 SHORT $LN7@ReadPhysic

; 129  : 		*BytesRead = BytesCopied;

  000bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR BytesCopied$[rsp]
  000c4	48 89 0b	 mov	 QWORD PTR [rbx], rcx
$LN7@ReadPhysic:

; 130  : 
; 131  : 	RandomDelay();

  000c7	e8 00 00 00 00	 call	 RandomDelay

; 132  : 	return status;

  000cc	8b c7		 mov	 eax, edi
  000ce	eb 05		 jmp	 SHORT $LN1@ReadPhysic
$LN3@ReadPhysic:

; 109  : 		return STATUS_INVALID_PARAMETER;

  000d0	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
$LN1@ReadPhysic:

; 133  : }

  000d5	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000da	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  000df	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000e4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
ReadPhysicalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT GetUserDirectoryTableBaseOffset
_TEXT	SEGMENT
GetUserDirectoryTableBaseOffset PROC			; COMDAT

; 96   : 	// The offset of DirectoryTableBase within the _KPROCESS structure
; 97   : 	// is 0x28 for most modern versions of Windows 10 and 11.
; 98   : 	// The previous hardcoded values were incorrect and caused the failure.
; 99   : 	return 0x28;

  00000	b8 28 00 00 00	 mov	 eax, 40			; 00000028H

; 100  : }

  00005	c3		 ret	 0
GetUserDirectoryTableBaseOffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT GetKernelFunction
_TEXT	SEGMENT
name$ = 32
FunctionName$ = 64
GetKernelFunction PROC					; COMDAT

; 82   : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 83   : 	UNICODE_STRING name;
; 84   : 	RtlInitAnsiString((PANSI_STRING)&name, (PCSZ)FunctionName);

  00004	48 8b d1	 mov	 rdx, rcx
  00007	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 85   : 	
; 86   : 	PVOID func = MmGetSystemRoutineAddress((PUNICODE_STRING)&name);

  00012	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress

; 87   : 	return func;
; 88   : }

  0001d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00021	c3		 ret	 0
GetKernelFunction ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT RandomDelay
_TEXT	SEGMENT
interval$ = 48
RandomDelay PROC					; COMDAT

; 66   : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 67   : 	LARGE_INTEGER interval;
; 68   : 	ULONG random = (ULONG)(__rdtsc() % 150);

  00004	0f 31		 rdtsc
  00006	48 c1 e2 20	 shl	 rdx, 32			; 00000020H
  0000a	48 0b c2	 or	 rax, rdx
  0000d	4c 8b c0	 mov	 r8, rax
  00010	48 b8 07 3a 6d
	a0 d3 06 3a 6d	 mov	 rax, 7870610804782742023 ; 6d3a06d3a06d3a07H
  0001a	49 f7 e0	 mul	 r8
  0001d	48 c1 ea 06	 shr	 rdx, 6
  00021	48 69 ca 96 00
	00 00		 imul	 rcx, rdx, 150		; 00000096H

; 69   : 	interval.QuadPart = -(10000LL * random);
; 70   : 	KeDelayExecutionThread(KernelMode, FALSE, &interval);

  00028	33 d2		 xor	 edx, edx
  0002a	4c 2b c1	 sub	 r8, rcx
  0002d	41 8b c0	 mov	 eax, r8d
  00030	4c 8d 44 24 30	 lea	 r8, QWORD PTR interval$[rsp]
  00035	48 69 c8 f0 d8
	ff ff		 imul	 rcx, rax, -10000	; ffffffffffffd8f0H
  0003c	48 89 4c 24 30	 mov	 QWORD PTR interval$[rsp], rcx
  00041	33 c9		 xor	 ecx, ecx
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeDelayExecutionThread

; 71   : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
RandomDelay ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT IsDebuggerPresent
_TEXT	SEGMENT
x$ = 8
IsDebuggerPresent PROC					; COMDAT

; 38   : 	// Check 1: Kernel debugger
; 39   : 	if (KD_DEBUGGER_ENABLED || !KD_DEBUGGER_NOT_PRESENT)

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KdDebuggerEnabled
  00007	80 38 00	 cmp	 BYTE PTR [rax], 0
  0000a	75 57		 jne	 SHORT $LN6@IsDebugger
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KdDebuggerNotPresent
  00013	80 38 00	 cmp	 BYTE PTR [rax], 0
  00016	74 4b		 je	 SHORT $LN6@IsDebugger

; 41   : 
; 42   : 	// Check 2: System debug flag
; 43   : 	if (*(PULONG)((PUCHAR)PsInitialSystemProcess + 0x2fc) & 0x400)

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_PsInitialSystemProcess
  0001f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00022	f7 81 fc 02 00
	00 00 04 00 00	 test	 DWORD PTR [rcx+764], 1024 ; 00000400H
  0002c	75 35		 jne	 SHORT $LN6@IsDebugger

; 44   : 		return TRUE;
; 45   : 
; 46   : 	// Check 3: Timing attack (debugger slows down execution)
; 47   : 	LARGE_INTEGER StartTime, EndTime;
; 48   : 	KeQuerySystemTime(&StartTime);

  0002e	49 b8 14 00 00
	00 80 f7 ff ff	 mov	 r8, -9345848836076	; fffff78000000014H

; 49   : 	
; 50   : 	// Dummy operations
; 51   : 	volatile int x = 0;

  00038	33 d2		 xor	 edx, edx
  0003a	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  0003d	89 54 24 08	 mov	 DWORD PTR x$[rsp], edx
$LL4@IsDebugger:

; 52   : 	for (int i = 0; i < 100; i++)
; 53   : 		x += i;

  00041	8b 44 24 08	 mov	 eax, DWORD PTR x$[rsp]
  00045	03 c2		 add	 eax, edx
  00047	ff c2		 inc	 edx
  00049	89 44 24 08	 mov	 DWORD PTR x$[rsp], eax
  0004d	83 fa 64	 cmp	 edx, 100		; 00000064H
  00050	7c ef		 jl	 SHORT $LL4@IsDebugger

; 54   : 	
; 55   : 	KeQuerySystemTime(&EndTime);

  00052	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 56   : 	
; 57   : 	// If took more than 1ms, likely debugged
; 58   : 	if ((EndTime.QuadPart - StartTime.QuadPart) > 10000)

  00055	48 2b c1	 sub	 rax, rcx
  00058	48 3d 10 27 00
	00		 cmp	 rax, 10000		; 00002710H
  0005e	7f 03		 jg	 SHORT $LN6@IsDebugger

; 59   : 		return TRUE;
; 60   : 
; 61   : 	return FALSE;

  00060	32 c0		 xor	 al, al

; 62   : }

  00062	c3		 ret	 0
$LN6@IsDebugger:

; 40   : 		return TRUE;

  00063	b0 01		 mov	 al, 1

; 62   : }

  00065	c3		 ret	 0
IsDebuggerPresent ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\ruskid2\driver\main.c
;	COMDAT XorDecrypt
_TEXT	SEGMENT
str$ = 8
len$ = 16
key$ = 24
XorDecrypt PROC						; COMDAT

; 31   : 	for (SIZE_T i = 0; i < len; i++)

  00000	41 0f be c0	 movsx	 eax, r8b
  00004	45 33 c9	 xor	 r9d, r9d
  00007	4c 8b d1	 mov	 r10, rcx
  0000a	66 0f 6e d0	 movd	 xmm2, eax
  0000e	66 0f 60 d2	 punpcklbw xmm2, xmm2
  00012	66 0f 61 d2	 punpcklwd xmm2, xmm2
  00016	66 0f 70 d2 00	 pshufd	 xmm2, xmm2, 0
  0001b	48 85 d2	 test	 rdx, rdx
  0001e	74 6f		 je	 SHORT $LN3@XorDecrypt
  00020	48 83 fa 40	 cmp	 rdx, 64			; 00000040H
  00024	72 55		 jb	 SHORT $LN17@XorDecrypt

; 32   : 		str[i] ^= key;

  00026	48 8b ca	 mov	 rcx, rdx
  00029	49 8d 42 20	 lea	 rax, QWORD PTR [r10+32]
  0002d	48 83 e1 c0	 and	 rcx, -64		; ffffffffffffffc0H
$LL4@XorDecrypt:
  00031	f3 0f 6f 40 e0	 movdqu	 xmm0, XMMWORD PTR [rax-32]
  00036	48 8d 40 40	 lea	 rax, QWORD PTR [rax+64]
  0003a	49 83 c1 40	 add	 r9, 64			; 00000040H
  0003e	66 0f 6f ca	 movdqa	 xmm1, xmm2
  00042	0f 57 c8	 xorps	 xmm1, xmm0
  00045	f3 0f 7f 48 a0	 movdqu	 XMMWORD PTR [rax-96], xmm1
  0004a	f3 0f 6f 40 b0	 movdqu	 xmm0, XMMWORD PTR [rax-80]
  0004f	0f 57 c2	 xorps	 xmm0, xmm2
  00052	f3 0f 7f 40 b0	 movdqu	 XMMWORD PTR [rax-80], xmm0
  00057	f3 0f 6f 48 c0	 movdqu	 xmm1, XMMWORD PTR [rax-64]
  0005c	0f 57 ca	 xorps	 xmm1, xmm2
  0005f	f3 0f 7f 48 c0	 movdqu	 XMMWORD PTR [rax-64], xmm1
  00064	f3 0f 6f 40 d0	 movdqu	 xmm0, XMMWORD PTR [rax-48]
  00069	0f 57 c2	 xorps	 xmm0, xmm2
  0006c	f3 0f 7f 40 d0	 movdqu	 XMMWORD PTR [rax-48], xmm0
  00071	4c 3b c9	 cmp	 r9, rcx
  00074	72 bb		 jb	 SHORT $LL4@XorDecrypt

; 31   : 	for (SIZE_T i = 0; i < len; i++)

  00076	4c 3b ca	 cmp	 r9, rdx
  00079	73 14		 jae	 SHORT $LN3@XorDecrypt
$LN17@XorDecrypt:
  0007b	4b 8d 04 11	 lea	 rax, QWORD PTR [r9+r10]
  0007f	49 2b d1	 sub	 rdx, r9
$LL8@XorDecrypt:

; 32   : 		str[i] ^= key;

  00082	44 30 00	 xor	 BYTE PTR [rax], r8b
  00085	48 8d 40 01	 lea	 rax, QWORD PTR [rax+1]
  00089	48 83 ea 01	 sub	 rdx, 1
  0008d	75 f3		 jne	 SHORT $LL8@XorDecrypt
$LN3@XorDecrypt:

; 33   : }

  0008f	c3		 ret	 0
XorDecrypt ENDP
_TEXT	ENDS
END
